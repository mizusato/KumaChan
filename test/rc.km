type TreeF[T] union {
    type Leaf Float;
    type Branch[T] (T,T);
};

type Tree TreeF[Tree];

private function iso: ( &(Tree) TreeF[Tree] )
    (&(t)(t));
private function iso-inv: ( &(TreeF[Tree]) Tree )
    (&(t)(Tree t));

public macro catamorphism(term, alg, cata):
    (term | iso | map (&(inner)(cata inner alg)) | alg);

public macro anamorphism(seed, coalg, ana):
    (seed | coalg | map (&(inner)(ana inner coalg)) | iso-inv);

public function map[A,B]: ( &(TreeF[A],(&(A)(B))) TreeF[B] )
    ( &(t, f)
        switch t:
        case Leaf x:
            x,
        case Branch (l, r):
            (Branch (f l) (f r)),
        end
    );

public function reduce[A]: ( &(Tree,(&(TreeF[A])(A))) A )
    ( &(t, alg) (catamorphism t alg reduce) );

public function build-tree[S]: ( &(S,(&(S)(TreeF[S]))) Tree )
    ( &(seed, coalg) (anamorphism seed coalg build-tree) );

private const a: Tree
    Tree (Branch (Tree (Leaf 1.0)) (Tree (Branch (Tree (Leaf 2.0)) (Tree (Leaf 3.0)))) );

private const b: Float
    (trace (a | reduce:[Float] (& (t)
        switch t:
        case Leaf x:
            x,
        case Branch (l, r):
            (+ l r),
        end
    )));

private const c: Seq[Float]
    (iterate [1.0, 2.0, 3.0, 4.0, 5.0]);

private const d: Tree
    (trace (c | build-tree:[Seq[Float]] (& (seq)
        switch seq | next:
        case Just (x, rest):
            switch rest | next:
            case Just _:
                (Branch (iterate [x]) rest),
            case N/A:
                Leaf x,
            end,
        case N/A:
            Leaf 0.0,
        end
    )));
