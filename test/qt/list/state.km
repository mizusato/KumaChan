type State {
    list:     Array[Item],
    current?: Maybe[String]
};

type Item {
    id: String,
    label: String
};

type Action union {
    type Add {
        id: String,
        label: String
    };
    type Remove {
        id: String
    };
    type MoveDown {
        id: String
    };
    type MoveUp {
        id: String
    };
};


private function adapt-item: ( &(Item) Qt::ListWidgetItem )
    ( & { id, label } (list-widget-item id KdfIcon label));

private function show-item: ( &(Maybe[Item]) NoExcept[-] )
    ( & item?
        switch item?:
        case Just { id, label }:
            ~ then (IdLabel.set-text id),
                   (ContentLabel.set-text label),
        case N/A:
            ~ then (IdLabel.set-text 'N/A'),
                   (ContentLabel.set-text 'N/A'),
        end
    );


private const @state: NoExcept*[State]
    combine-latest @list @current
        | map* ( &(list?, current??)
            State {
                list:     (fallback? list? []),
                current?: (unwrap? current??)
            }
        );

private const @list: NoExcept*[Array[Item]]
    (@action | scan (:Array[Item]: []) ( &(list,action?)
        switch action?:
        case Just action:
            switch action:
            case Add { id, label }:
                collect (cons (Item { id, label }) (iterate list)),
            case Remove { target: id }:
                list | filter ( &{id} $(id != target) ),
            case MoveDown { target: id }:
                let t := list.reduce (No, (:Seq[Item]: nil())) ( &(t, item)
                    let (ok, seq) := t,
                    switch seq.next:
                    case Just (prev, rest):
                        if $((not ok) and $(${prev}.id = target)):
                            (Yes, (cons prev (cons item rest))),
                        else:
                            (No, (cons item seq)),
                    case N/A:
                        (No, (cons item seq)),
                    end
                ),
                let (_, seq) := t,
                seq.collect.reverse,
            case MoveUp { target: id }:
                let t := list.reduce (No, (:Seq[Item]: nil())) ( &(t, item)
                    let (ok, seq) := t,
                    switch seq.next:
                    case Just (prev, rest):
                        if $((not ok) and $(${item}.id = target)):
                            (Yes, (cons prev (cons item rest))),
                        else:
                            (No, (cons item seq)),
                    case N/A:
                        (No, (cons item seq)),
                    end
                ),
                let (_, seq) := t,
                seq.collect.reverse,
            end,
        case N/A:
            list,
        end
    ));

private const @current: NoExcept*[Maybe[String]]
    TodoList.current-item;
private function with-current-item:
    ( &(NoExcept*[-], (&(String)(Action))) NoExcept*[Maybe[Action]] )
    ( &(signal, transform)
        signal | with-latest-from @current
               | map* ( &(_, current??)
                   ~ maybe &(current) := (unwrap? current??),
                   transform current
               )
    );

private const @action: NoExcept*[Maybe[Action]]
    merge [@add, @remove, @move-down, @move-up];

private const @add: NoExcept*[Maybe[Action]]
    merge [AddButton.clicked, TodoInput.enter]
        | with-latest-from (TodoInput.text)
        | concat-map ( &(_,label?)
            ~ map* &(x) := random (),
            ~ maybe? &(label) := label?,
                if $((label.length) > 0):
                    Just (Add { id: (str x), label }),
                else:
                    N/A
        );

private const @remove: NoExcept*[Maybe[Action]]
    RemoveButton.clicked
        | with-current-item (&(current)
            Remove { id: current } );

private const @move-down: NoExcept*[Maybe[Action]]
    DownButton.clicked
        | with-current-item ( &(current)
            MoveDown { id: current }
        );

private const @move-up: NoExcept*[Maybe[Action]]
    UpButton.clicked
        | with-current-item ( &(current)
            MoveUp { id: current }
        );
