1. Scope

Prevent closures from capturing the entire scope. Capture individual variables instead.

----------------------------------------

2. Function

Upgrade UFCS to pipeline: F(x) -> (G())(arg2, arg3) <=> (G())(F(x), arg2, arg3)
Separate:
    - Get/Set Syntax: object[key]
    - Method/Field Syntax: object.field
    - UFCS/Pipeline Syntax: object -> f(arg2, arg3)

----------------------------------------

3. Class & Schema

- Support both "self" (the instance itslf) and "Self" (the class itself) in instance scopes
- Support immutable structs (syntax: "immutable S { FIELD1: TYPE1, ... }")
- Support schema definition in enum and struct destruct in switch match statement
- Use schema subtyping instead of struct-to-struct cast

----------------------------------------

4. Type System

The initial implementation of KumaChan runtime allows side-effect
    during type checking, and type template (mechanics of generics) can
    cause memory leak. Definition of a type can change over time.
Those caveats of type system will be fixed in the new implementation.
    - Use <- (belongs to) instead of 'is' operator; add < (subset operator)
    - Use : instead of 'is' in class definition
    - Implement PlainType using native function (no side-effect)
    - Assign a unique ID (uint64) for each atomic type
    - Assign a name for each type ID
    - Make CompoundType only support union and intersection (no complement)
    - Normalize a CompoundType to a union of intersections and atomic types
    - Restrict arguments of TypeTemplate to global types
    - Global types are types defined in the global scope (built-in),
        or types defined in module scopes by the "type T = .." statement
    - Placeholders in function signature (e.g. $<?><?>) should not be supported
    - Remove FiniteSetType.
    - Enum is no longer atomic, just a union type
    - Enable subset/superset check:
        - Int is Subset<Int|String>
        - SomeClass is Subset<SomeInterface>
    - A built-in generic type may have a literal, or can be created by type cast
        - Tuple2<T1,T2>; Tuple3<T1,T2,T3>; Tuple4<T1,T2,T3,T4>; Tuple5
            - tuple { 1, '1' }; Tuple3<Int,Int,String>(1,2,'3')
        - Array<T>
            - array<Int> {1,2,3}; array<Int>(iterable)
        - Map<K,V>
            - map<String,Int> { 'a': 1, 'b': 2, 'c': 3 }
        - Iterator<T>
            - iterator<T> { BODY }; iterator { BODY }
        - Stream<T> (AsyncIterator<T>)
            - stream<T> { BODY }; stream { BODY }
        - Source<T>
            - source<T> { BODY }; source { BODY }
        - Promise<T>
            - promise<T> { BODY }; promise { BODY }
        - Error<T>
            - Error<T>(FoobarError)
    - Above cast is based on subset/superset check
    - Above types are classes which are wrappers of native objects
    - Support interface inheritance
    - Support Function Template:
        - function map<T,U>(i: Iterator<T>, f: $<T><U>) -> Iterator<U> { ... }
    - Implement restrictions on function template parameters by subtype check
        - 'func Foo<T: R>() ...' means ensuring T < R and assuming T = R in '...'
        - 'class Foo<T>: .. ...' means assuming T = Any in '...'

----------------------------------------

5. Misc

- Support nested loop semantics in list comprehension
- Support sub-module definition
- Support replace-current-frame call: return exec f()
