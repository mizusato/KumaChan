1. Scope

Prevent closures from capturing the entire scope. Capture individual variables instead.

----------------------------------------

2. Function

Upgrade UFCS to pipeline: F(x) -> (G())(arg2, arg3) <=> (G())(F(x), arg2, arg3)
Separate:
    - Get/Set Syntax: object[key]
    - Method/Field Syntax: object.field
    - UFCS/Pipeline Syntax: object -> f(arg2, arg3)

----------------------------------------

3. Class & Schema

- Support both "self" (the instance itslf) and "Self" (the class itself) in instance scopes
- Support immutable structs (syntax: "immutable S { FIELD1: TYPE1, ... }")
- Support schema definition in enum and struct destruct in switch match statement
- Use schema subtyping instead of struct-to-struct cast

----------------------------------------

4. Type System

The initial implementation of KumaChan runtime allows side-effect
    during type checking, and type template (mechanics of generics) can
    cause memory leak. Definition of a type can change over time.
Those caveats of type system will be fixed in the new implementation.
    - Implement SimpleType using native function (no side-effect)
    - Assign a unique ID (uint64) for each atomic type
    - Assign a name for each type ID
    - Make CompoundType only support union and intersection (no complement)
    - Normalize a CompoundType to a union of intersections and atomic types
    - Restrict arguments of TypeTemplate to global types
    - Global types are types defined in the global scope (built-in),
        or types defined in module scopes by the "type T = .." statement
    - Default inflation of TypeTemplate (TT<>) only works for:
        - class (inject a empty interface)
        - interface (inject a empty base interface)
        - built-in generic types (promise, array, iterator...)
        - e.g. Array<> and SomeClass<> are valid, but Maybe<> is invalid
    - SignatureType (function signature) can be regarded as a special kind of
        GentericType, thus the restrictions on GenericType also applies to it
    - Placeholders in function signature (e.g. $<?><?>) should not be supported
    - FiniteSetType is no longer atomic. {A, B, C, ...} should be a sugar of
        IsExactly<A> | IsExactly<B> | IsExactly<C> | ...
    - IsExactly<T> = {T} (OneElementType<T>)
    - Enum is no longer atomic
    - Enable subset/superset check:
        - Int is Subset<Int|String>
        - SomeClass is Subset<SomeInterface>
    - A built-in generic type may have a literal, or can be created by type cast
        - Array<>, ArrayView<>
            - array<Int> {1,2,3}; array<Int>(iterable)
            - array1 as ArrayView<Int>; ArrayView<Int> from array2
            - const array<Int> {1,2,3}
        - Map<>, MapView<>
            - map<String,Int> { 'a': 1, 'b': 2, 'c': 3 }
            - map1 as MapView<Primitive>; MapView<Primitive> from map1
            - const map<Int,Int> { 0: 1, 1: 2, 2: 4 }
        - Iterator<>
            - iterator<T> { BODY }; iterator { BODY }
            - another as Iterator<T>; Iterator<T> from another
        - AsyncIterator<>
            - async iterator<T> { BODY }; async iterator { BODY }
            - another as AsyncIterator<T>; AsyncIterator<T> from another
        - Source<>
            - source<T> { BODY }; source { BODY }
            - another as Source<T>; Source<T> from another
        - Promise<>
            - promise<T> { BODY }; promise { BODY }
            - another as Promise<T>; Promise<T> from another
        - Error<>
            - FooBarFailed as Error<T>; Error<T> from BazInvalid { ... }
    - Above cast is based on subset/superset check
    - (duck VALUE) operator to inform the compiler to use duck typing

----------------------------------------

5. Misc

- Support nested loop semantics in list comprehension
- Support sub-module definition
- Support replace-current-frame call: return exec f()
