1. Scope

Prevent closures from capturing the entire scope. Capture individual variables instead.

----------------------------------------

2. Class & Schema

- Support both "self" (the instance itslf) and "Self" (the class itself) in instance scopes
- Support "MaybeSelf" field type in schema definition
- Support immutable structs (syntax: "immutable S { FIELD1: TYPE1, ... }")
- Support schema definition in enum and struct destruct in switch match statement

----------------------------------------

3. Type System

The initial implementation of KumaChan runtime allows side-effect
    during type checking, and type template (mechanics of generics) can
    cause memory leak. Definition of a type can change over time.
Those caveats of type system will be fixed in the new implementation.
    - Change "SimpleType" to "SubType", restrict condition expressions.
    - SubType can only be subset of primitive types or immutable struct types
    - Assign a unique ID (uint64) for each atomic type
    - Assign a name for each type ID
    - Use normal form of propositional formula instead of iterating truth table
    - Change "TypeTemplate" to "GenericType"
    - Restrict arguments of GenericType to global types and primitive constants
    - Global types are types defined in the global scope (built-in),
        or types defined in module scopes by the "type T = .." statement
    - GenericType *itself* only works for class, interface, and schema
        - e.g. class Foo<T> { .. } is of Foo type,
               but type Foo<T> = invoke { class Bar { .. }; return Bar } is NOT
        - implement this feature by assign a common ID to the
               relationship between GenericType and class/... when compiling
        - forbid meaningless direct use of GenericType, e.g. "x is Maybe"
    - SignatureType (function signature) can be regarded as a special kind of
        GentericType, thus the restrictions on GenericType also applies to it
    - FiniteSetType is no longer atomic. {A, B, C, ...} should be a sugar of
        IsExactly<A> | IsExactly<B> | IsExactly<C> | ...

----------------------------------------

4. Misc

- Support nested loop semantics in list comprehension
- Support SubModule definition
- Support replace-current-frame call: return exec f()
