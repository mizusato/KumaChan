package syntax

import "regexp"
type Regexp = *regexp.Regexp
func r (pattern string) Regexp { return regexp.MustCompile(`^` + pattern) }

const LF = `\n`
const Blanks = ` \t\rã€€`
const Symbols = `;\{\}\[\]\(\)\.\,\:@\?\<\>\=\!~\&\|\\\+\-\*\/%\^'"` + "`"

var EscapeMap = map [string] string {
    "_exc":   "!",
    "_bar1":  "|",
    "_bar2":  "||",
    "_at":    "@",
    "_tree":  "|->",
}


var Extra = [...] string { "Call", "Get", "Void" }

var Tokens = [...] Token {
    Token { Name: "MulStr",  Pattern: r(`'''([^']|'[^']|''[^'])+'''`) },
    Token { Name: "String",  Pattern: r(`'[^'\n]*'`) },
    Token { Name: "String",  Pattern: r(`"[^"\n]*"`) },
    Token { Name: "Comment", Pattern: r(`/\*([^\*]|[^/]|\*[^/]|[^\*]/)*\*/`) },
    Token { Name: "Comment", Pattern: r(`//[^\n]*`) },
    Token { Name: "Pragma",  Pattern: r(`#[^\n]*`) },
    Token { Name: "<<",      Pattern: r(`\<\<`) },
    Token { Name: ">>",      Pattern: r(`\>\>`) },
    Token { Name: "Blank",   Pattern: r(`[`+Blanks+`]+`) },
    Token { Name: "LF",      Pattern: r(LF+`+`) },
    Token { Name: "LF",      Pattern: r(`;+`) },
    Token { Name: "Hex",     Pattern: r(`0x[0-9A-Fa-f]+`) },
    Token { Name: "Oct",     Pattern: r(`\\[0-7]+`) },
    Token { Name: "Bin",     Pattern: r(`\\\([01]+\)`) },
    Token { Name: "Exp",     Pattern: r(`\d+(\.\d+)?[Ee][\+\-]?\d+`) },
    Token { Name: "Dec",     Pattern: r(`\d+\.\d+`) },
    Token { Name: "Int",     Pattern: r(`\d+`) },
    Token { Name: "(",       Pattern: r(`\(`) },
    Token { Name: ")",       Pattern: r(`\)`) },
    Token { Name: "[",       Pattern: r(`\[`) },
    Token { Name: "]",       Pattern: r(`\]`) },
    Token { Name: "{",       Pattern: r(`\{`) },
    Token { Name: "}",       Pattern: r(`\}`) },
    Token { Name: "...",     Pattern: r(`\.\.\.`) },
    Token { Name: ".",       Pattern: r(`\.`) },
    Token { Name: ",",       Pattern: r(`\,`) },
    Token { Name: "::",      Pattern: r(`\:\:`) },
    Token { Name: ":",       Pattern: r(`\:`) },
    Token { Name: "@",       Pattern: r(`@`) },
    Token { Name: "??",      Pattern: r(`\?\?`) },
    Token { Name: "?",       Pattern: r(`\?`) },
    Token { Name: ">=",      Pattern: r(`\>\=`) },
    Token { Name: "<=",      Pattern: r(`\<\=`) },
    Token { Name: "==",      Pattern: r(`\=\=`) },
    Token { Name: "!=",      Pattern: r(`\!\=`) },
    Token { Name: "~~",      Pattern: r(`\~\~`) },
    Token { Name: "!~",      Pattern: r(`\!\~`) },
    Token { Name: "=>",      Pattern: r(`\=\>`) },
    Token { Name: "=",       Pattern: r(`\=`) },
    Token { Name: "->",      Pattern: r(`\-\>`) },
    Token { Name: "<-",      Pattern: r(`\<\-`) },
    Token { Name: "<",       Pattern: r(`\<`) },
    Token { Name: ">",       Pattern: r(`\>`) },
    Token { Name: "!",       Pattern: r(`\!`) },
    Token { Name: "&&",      Pattern: r(`\&\&`) },
    Token { Name: "|->",     Pattern: r(`\|\-\>`) },
    Token { Name: "||",      Pattern: r(`\|\|`) },
    Token { Name: "~",       Pattern: r(`~`) },
    Token { Name: "&",       Pattern: r(`\&`) },
    Token { Name: "|",       Pattern: r(`\|`) },
    Token { Name: `\`,       Pattern: r(`\\`) },
    Token { Name: "+",       Pattern: r(`\+`) },
    Token { Name: "-",       Pattern: r(`\-`) },
    Token { Name: "**",      Pattern: r(`\*\*`) },
    Token { Name: "*",       Pattern: r(`\*`) },
    Token { Name: "/",       Pattern: r(`\/`) },
    Token { Name: "%",       Pattern: r(`%`) },
    Token { Name: "^",       Pattern: r(`\^`) },
    Token { Name: "Name",    Pattern: r(`[^`+Symbols+Blanks+LF+`]+`) },
    //    { Name: "Call",    [ Inserted by Scanner ] },
    //    { Name: "Get",     [ Inserted by Scanner ] },
    //    { Name: "Void",    [ Inserted by Scanner ] },
}


/* Conditional Keywords */
var Keywords = [...] string {
    
    "@module", "@export", "@import", "@from", "@as",
    
    "@type", "@new", "@singleton",
    "@function", "@static", "@mock",
    "@handle", "@unless", "@failed", "@finally",
    "@enum",
    "@struct", "@immutable", "@operator", "@negate", "@not",
    "@class", "@init", "@create", "@private",
    "@interface",
    
    "@if", "@else", "@switch", "@otherwise",
    "@while", "@for", "@in", "@break", "@continue",
    "@return", "@yield", "@await",
    "@assert", "@throw", "@panic", "@ensure", "@try", "@to",
    "@let",  "@initial", "@reset",
    "@set", "@do", "@nothing",
    
    "@mount", "@push",
    "@$", "@when", "@match", "@tree", "@lambda", "@invoke",
    "@true", "@false", 
    
}


/* Infix Operators */
var Operators = [...] Operator {
    /* Fallback */
    Operator { Match: "??",   Priority: 60,  Assoc: Left,   Lazy: true   },
    /* Comparison */
    Operator { Match: "<",    Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: ">",    Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: "<=",   Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: ">=",   Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: "==",   Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: "!=",   Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: "~~",   Priority: 50,  Assoc: Left,   Lazy: false  },
    Operator { Match: "!~",   Priority: 50,  Assoc: Left,   Lazy: false  },
    /* Logic */
    Operator { Match: "&&",   Priority: 40,  Assoc: Left,   Lazy: true   },
    Operator { Match: "||",   Priority: 30,  Assoc: Left,   Lazy: true   },
    /* Arithmetic */
    Operator { Match: "+",    Priority: 70,  Assoc: Left,   Lazy: false  },
    Operator { Match: "-",    Priority: 70,  Assoc: Left,   Lazy: false  },
    Operator { Match: "*",    Priority: 80,  Assoc: Left,   Lazy: false  },
    Operator { Match: "/",    Priority: 80,  Assoc: Left,   Lazy: false  },
    Operator { Match: "%",    Priority: 80,  Assoc: Left,   Lazy: false  },
    Operator { Match: "^",    Priority: 90,  Assoc: Right,  Lazy: false  },
}


var RedefinableOperators = []string {
    "==", "<",
    "@negate", "+", "-", "*", "/", "%", "^",
}


var SyntaxDefinition = [...] string {
    /* Group: Root */
    "eval = imports decls commands",
    "module = shebang @module! name! export imports decls commands",
      "shebang? = Pragma",
      "name = Name",
      "export? = @export { namelist! }! | @export namelist!",
        "namelist = name namelist_tail",
        "namelist_tail? = , name! namelist_tail",
      "imports? = import imports",
        "import = import_all | import_names | import_module",
          "import_names = @import as_list @from name",
            "as_list = as_item as_list_tail",
              "as_list_tail? = , as_item! as_list_tail",
              "as_item = name @as name! | name",
          "import_module = @import as_item",
          "import_all = @import * @from name",
      // decls -> Group: Declaration
      "commands? = command commands",
        // command -> Group: Command
    /* Group: Declaration */
    "decls? = decl decls",
      "decl = type_alias | function | enum | schema | class | interface",
        "type_alias = singleton | @type name type_params = type",
          "singleton = @type name = @new @singleton",
          "type_params? = [ weak_list ]!",
            "weak_list = weak_list_item weak_list_tail",
            "weak_list_tail? = , weak_list_item! weak_list_tail",
            "weak_list_item = name : type! | name",
          "type = union",
            "union = intersect union_tail",
              "union_tail? = | intersect! union_tail",
              "intersect = type_operand intersect_tail",
                "intersect_tail? = & type_operand! intersect_tail",
                "type_operand = type_wrapped | type_ordinary | fun_sig",
                  "type_wrapped = ( type )!",
                  "type_ordinary = name field_gets type_args",
                    "field_gets? = field_get field_gets",
                      "field_get = Get . name!",
                    "type_args? = [ typelist! ]!",
                      "typelist = type typelist_tail",
                      "typelist_tail? = , type! typelist_tail",
                  "fun_sig = [ -> type! ]! | [ typelist! ->! type! ]!",
        "function = f_overload | f_single",
          "f_single = @function name type_params paralist! ->! type! body!",
            "paralist = ( ) | ( typed_list! )!",
              "typed_list = typed_list_item typed_list_tail",
              "typed_list_tail? = , typed_list_item! typed_list_tail",
              "typed_list_item = name :! type!",
            "body = { static_commands commands mock_hook handle_hook }!",
              "static_commands? = @static { commands }",
              "mock_hook? = ... @mock name! { commands }",
              "handle_hook? = ... @handle name { handle_cmds }! finally",
                "handle_cmds? = handle_cmd handle_cmds",
                  "handle_cmd = unless | failed",
                    "unless = @unless name unless_params { commands }",
                      "unless_params? = Call ( typed_list! )!",
                    "failed = @failed opt_to name { commands }",
                      "opt_to? = @to",
                "finally? = @finally { commands }",
          "f_overload = @function name type_params { f_item_list }",
            "f_item_list = f_item f_item_list_tail",
              "f_item_list_tail? = , f_item! f_item_list_tail",
              "f_item = paralist! ->! type! body!",
        "enum = @enum name {! enum_item enum_tail }!",
          "enum_tail? = , enum_item! enum_tail",
          "enum_item = schema | name",
        "schema = schema_kind name type_params bases {! field_list! oplist }!",
          "schema_kind = @struct | @immutable",
          "bases? = : typelist!",
          "field_list = field field_list_tail",
            "field_list_tail? = , field! field_list_tail",
            "field = name : type! field_default",
              "field_default? = = expr",
          "oplist? = ... op_def oplist_tail",
            "oplist_tail? = op_def oplist_tail",
            "op_def = @operator custom_op! custom_op_fun",
              "custom_op = op_arith | @negate",
              "custom_op_fun = (! namelist! )! body!",
        "class = @class name type_params bases { init pfs methods oplist }",
          "init = @init paralist! body! creators",
          "creators? = creator creators",
            "creator = @create paralist! body!",
          "pfs? = pf pfs",
            "pf = @private name paralist! ->! type! body!",
          "methods? = method methods",
            "method = name paralist! ->! type! body!",
        "interface = @interface name type_params { method_protos }!",
          "method_protos? = method_proto method_protos",
            "method_proto = name paralist! ->! type!",
    /* Group: Command */
    "command = cmd_group1 | cmd_group2 | cmd_group3",
      "cmd_group1 = cmd_branch | cmd_loop | cmd_loop_ctrl",
        "cmd_branch = cmd_if | cmd_switch",
          "cmd_if = @if expr! block! elifs else",
            "block = { commands }!",
            "elifs? = elif elifs",
              "elif = @else @if expr! block!",
            "else? = @else block!",
          "cmd_switch = switch_when | switch_match",
            "switch_when = @switch @when {! cases! }!",
              "cases = case more_cases",
                "more_cases? = case more_cases",
                "case = @otherwise => block! | expr => block!",
            "switch_match = @switch @match expr {! cases! }!",
        "cmd_loop = cmd_while | cmd_for",
          "cmd_while = @while expr! block!",
          "cmd_for = @for for_params! @in expr! block!",
            "for_params = value_with_key | value_with_index | value",
              "value_with_index = name [ for_index! ]!",
                "for_index = name",
              "value_with_key = { for_key :! name! }!",
                "for_key = name",
              "value = name",
        "cmd_loop_ctrl = @break | @continue",
      "cmd_group2 = cmd_return | cmd_pause | cmd_abrupt | cmd_guard",
        "cmd_return = @return Void | @return expr",
        "cmd_pause = cmd_yield | cmd_async_for | cmd_await",
          "cmd_yield = @yield pattern = expr! | @yield expr!",
            "pattern = name | { namelist }! | [ namelist ]!",
          "cmd_await = @await pattern = expr! | @await expr!",
          "cmd_async_for = @await name @in expr! block!",
        "cmd_abrupt = cmd_throw | cmd_panic",
          "cmd_throw = @throw expr!",
          "cmd_panic = @panic expr!",
        "cmd_guard = cmd_assert | cmd_ensure | cmd_try",
          "cmd_assert = @assert expr!",
          "cmd_ensure = @ensure name! ensure_args { expr! }!",
            "ensure_args? = Call ( exprlist )",
              "exprlist = expr exprlist_tail",
                "exprlist_tail? = , expr! exprlist_tail",
                // expr -> Group: Expression
          "cmd_try = @try opt_to name { commands }!",
      "cmd_group3 = cmd_scope | cmd_set | cmd_side_effect | cmd_pass",
        "cmd_scope = cmd_let | cmd_initial | cmd_reset",
          "cmd_let = @let pattern = expr!",
          "cmd_initial = @initial name = var_type expr!",
            "var_type? = ( @as type! )! :!",
          "cmd_reset = @reset name set_op = expr",
            "set_op? = op_arith",
        "cmd_set = @set left_val set_op = expr",
          "left_val = operand_body",
          // operand_body -> Group: Operand
        "cmd_side_effect = expr",
        "cmd_pass = @do @nothing",
    /* Group: Expression */
    "expr = lower_unary operand expr_tail | operand expr_tail",
      "lower_unary = @mount | @push",
      "expr_tail? = operator operand! expr_tail",
        // operand -> Group: Operand
        "operator = op_fallback | op_compare | op_logic | op_arith",
          "op_fallback = ?? ",
          "op_compare = < | > | <= | >= | == | != | ~~ | !~ ",
          `op_logic = && | _bar2 `,
          "op_arith = + | - | * | / | % | ^ ",
    /* Group: Operand */
    "operand = operand_body calls",
      "operand_body = unary operand_base operand_tail",
        "unary? = @not | _exc | - ",
        "operand_base = wrapped | primitive | new | misc_expr | identifier",
          "wrapped = ( expr! )!",
          "primitive = string | number | bool",
            "string = String | MulStr",
            "number = Hex | Exp | Dec | Int",
            "bool = @true | @false",
          "new = @new type new_args",
            "new_args? = literal | Call ( arglist )!",
              "literal = : map | : list | struct | body",
                "map = [ ] | [ map_item! map_tail ]!",
                  "map_tail? = , map_item! map_tail",
                  "map_item = expr : expr!",
                "list = [ ] | [ list_item! list_tail ]!",
                  "list_tail? = , list_item list_tail",
                  "list_item = expr",
                "struct = { } | { struct_item struct_tail }!",
                  "struct_tail? = , struct_item struct_tail",
                  "struct_item = name = expr! | name!",
          "misc_expr = type_expr | text | when | match | lambda | iife | tree",
            "type_expr = @type { type }",
            "text = @$ segment more_segment",
              "segment = { segment_tag segment_content! }!",
                "segment_tag? = name : ",
                "segment_content = string | expr",
              "more_segment? = segment more_segment",
            "when = @when {! branch_list }!",
              "branch_list = branch! branch_list_tail",
              "branch_list_tail? = , branch! branch_list_tail",
              "branch = @otherwise :! expr! | expr! :! expr!",
            "match = @match expr {! branch_list }!",
            "lambda = @lambda type_params paralist_weak ret_weak body_flex",
              "paralist_weak? = name | ( ) | ( weak_list! )!",
              "ret_weak? = -> type",
              "body_flex = => body | => expr! | body!",
            "iife = @invoke body",
            "tree = _tree tree_node! | @tree { tree_node! }!",
              "tree_node = type { node_props node_children }!",
                "node_props? = node_prop node_props",
                  "node_prop = name = expr! | string = expr!",
                "node_children? = node_child node_children",
                  "node_child = tree_node | = expr",
          "identifier = Name",
        "operand_tail? = tail_operation operand_tail",
          "tail_operation = field_get | slice | get | inflate",
            "slice = Get [ low_bound : high_bound ]!",
              "low_bound? = expr",
              "high_bound? = expr",
            "get = Get [ exprlist! ]! nil_flag",
              "nil_flag? = ?",
            "inflate = :: [ typelist! ]!",
      "calls = plain_calls pipelines",
        "plain_calls? = plain_call plain_calls",
          "plain_call = Call ( arglist )!",
            "arglist? = exprlist",
        "pipelines? = pipeline pipelines",
          "pipeline = => operand_body pipeline_args",
          "pipeline_args? = Call ( arglist )!",
}
