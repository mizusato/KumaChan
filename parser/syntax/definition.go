package syntax

import "regexp"
type Regexp = *regexp.Regexp
func r (pattern string) Regexp { return regexp.MustCompile(`^` + pattern) }

const LF = `\n`
const Blanks = ` \t\rã€€`
const Symbols = `;\{\}\[\]\(\)\.\,\:\$#@\?\<\>\=\!~\&\|\\\+\-\*\/%\^'"` + "`"

var EscapeMap = map [string] string {
    "_exc1":  "!",
    "_exc2":  "!!",
    "_bar1":  "|",
    "_bar2":  "||",
    "_at":    "@",
}

var Tokens = [...] Token {
    Token { Name: "String",  Pattern: r(`'[^']*'`) },
    Token { Name: "Text",    Pattern: r(`"[^"#\[\]]*"`) },
    Token { Name: "TxBegin", Pattern: r(`"[^"#\[\]]*#\[`) },
    Token { Name: "TxInner", Pattern: r(`\][^"#\[\]]*#\[`) },
    Token { Name: "TxEnd",   Pattern: r(`\][^"#\[\]]*"`) },
    Token { Name: "Comment", Pattern: r(`/\*([^\*]|[^/]|\*[^/]|[^\*]/)*\*/`) },
    Token { Name: "Comment", Pattern: r(`//[^;`+LF+`]*`) },
    Token { Name: "Pragma",  Pattern: r(`#[^;`+LF+`]*`) },
    Token { Name: "Blank",   Pattern: r(`[`+Blanks+`]+`) },
    Token { Name: "LF",      Pattern: r(`[;`+LF+`]+`) },
    Token { Name: "Hex",     Pattern: r(`0x[0-9A-Fa-f]+`) },
    Token { Name: "Oct",     Pattern: r(`\\[0-7]+`) },
    Token { Name: "Bin",     Pattern: r(`\\\([01]+\)`) },
    Token { Name: "Exp",     Pattern: r(`\d+(\.\d+)?[Ee][\+\-]?\d+`) },
    Token { Name: "Float",   Pattern: r(`\d+\.\d+`) },
    Token { Name: "Dec",     Pattern: r(`\d+`) },
    Token { Name: "(",       Pattern: r(`\(`) },
    Token { Name: ")",       Pattern: r(`\)`) },
    Token { Name: "[",       Pattern: r(`\[`) },
    Token { Name: "]",       Pattern: r(`\]`) },
    Token { Name: "{",       Pattern: r(`\{`) },
    Token { Name: "}",       Pattern: r(`\}`) },
    Token { Name: "...",     Pattern: r(`\.\.\.`) },
    Token { Name: "..",      Pattern: r(`\.\.`) },
    Token { Name: ".",       Pattern: r(`\.`) },
    Token { Name: ",",       Pattern: r(`\,`) },
    Token { Name: "::",      Pattern: r(`\:\:`) },
    Token { Name: ":",       Pattern: r(`\:`) },
    Token { Name: "$",       Pattern: r(`\$`) },
    Token { Name: "$$",      Pattern: r(`\$$`) },
    Token { Name: "@",       Pattern: r(`@`) },
    Token { Name: "@@",      Pattern: r(`@@`) },
    Token { Name: "??",      Pattern: r(`\?\?`) },
    Token { Name: "?",       Pattern: r(`\?`) },
    Token { Name: "Name",    Pattern: r(`\>\=`) },
    Token { Name: "Name",    Pattern: r(`\<\=`) },
    Token { Name: "Name",    Pattern: r(`\=\=`) },
    Token { Name: "Name",    Pattern: r(`\!\=`) },
    Token { Name: "=>",      Pattern: r(`\=\>`) },
    Token { Name: "=",       Pattern: r(`\=`) },
    Token { Name: "->",      Pattern: r(`\-\>`) },
    Token { Name: "<-",      Pattern: r(`\<\-`) },
    Token { Name: "<<",      Pattern: r(`\<\<`) },
    Token { Name: ">>",      Pattern: r(`\>\>`) },
    Token { Name: "Name",    Pattern: r(`\<`) },
    Token { Name: "Name",    Pattern: r(`\>`) },
    Token { Name: "!!",      Pattern: r(`\!\!`) },
    Token { Name: "!",       Pattern: r(`\!`) },
    Token { Name: "~",       Pattern: r(`~`) },
    Token { Name: "&&",      Pattern: r(`\&\&`) },
    Token { Name: "&",       Pattern: r(`\&`) },
    Token { Name: "||",      Pattern: r(`\|\|`) },
    Token { Name: "|",       Pattern: r(`\|`) },
    Token { Name: `\`,       Pattern: r(`\\`) },
    Token { Name: "Name",    Pattern: r(`\+\+`) },
    Token { Name: "Name",    Pattern: r(`\+`) },
    Token { Name: "Name",    Pattern: r(`\--`) },
    Token { Name: "Name",    Pattern: r(`\-`) },
    Token { Name: "Name",    Pattern: r(`\*\*`) },
    Token { Name: "Name",    Pattern: r(`\*`) },
    Token { Name: "Name",    Pattern: r(`\/`) },
    Token { Name: "Name",    Pattern: r(`%%`) },
    Token { Name: "Name",    Pattern: r(`%`) },
    Token { Name: "Name",    Pattern: r(`\^\^`) },
    Token { Name: "Name",    Pattern: r(`\^`) },
    Token { Name: "Name",    Pattern: r(`[^`+Symbols+Blanks+LF+`]+`) },
    //    { Name: "NoLF",    [ Inserted by Scanner ] },
    //    { Name: "Void",    [ Inserted by Scanner ] },
}

var ExtraTokens = [...] string { "NoLF", "Void" }

var ConditionalKeywords = [...] string {
    "@module", "@import", "@from",
    "@global", "@local",
    "@type", "@opaque", "@union", "@native",
    "@fun", "@val", "@do",
    "@if", "@else", "@match", "@default",
    "@let", "@return",
    "@Yes", "@No",
}

var Operators = [...] Operator {}

var SyntaxDefinition = [...] string {
    "module = shebang module_name! commands",
      "shebang? = Pragma",
      "module_name = @module name!",
        "name = Name",
      "commands?  = command commands",
        "command = import | decl | do",
          "import = @import name! @from! string!",
          "decl = decl_type | decl_fun | decl_val",
          "do = @do expr!",
    "ref = module_prefix name type_args",
      "module_prefix? = name ::",
      "type_args? = [ type! more_types ]",
        "more_types? = , type! more_types",
    "type = type_ref | type_literal",
      "type_ref = ref",
      "type_literal = repr",
    "decl_type = single_type | union_type",
      "union_type = type_opts @union @type name! type_params { decl_type more_decl_types }",
        "type_opts = visibility opaque_opt",
          "visibility? = @global | @local",
          "opaque_opt? = @opaque",
        "more_decl_types? = decl_type more_decl_types",
      "single_type = type_opts @type name! type_params repr!",
        "type_params? = [ type_param! more_type_params ]!",
          "more_type_params? = , type_param! more_type_params",
          "type_param = name",
        "repr = repr_tuple | repr_bundle | repr_func | repr_native",
          "repr_tuple = ( ) | ( type! more_types )!",
          "repr_bundle = { } | { field! more_fields }!",
            "field = name :! type!",
            "more_fields? = , field! more_fields",
          "repr_func = [ signature! ]!",
            "signature = input_type ->! output_type!",
              "input_type = type",
              "output_type = type",
          "repr_native = @native string",
    "decl_fun = visibility @fun name! type_params =! [! signature! ]! lambda!",
      "lambda = pattern => term!",
        "pattern = pattern_none | pattern_tuple | pattern_bundle",
          "pattern_none = name",
          "pattern_tuple = ( ) | ( name more_names )",
            "more_names? = , name more_names",
          "pattern_bundle = { } | { name more_names }",
    "decl_val = visibility @val name! =! expr!",
    "expr = casts term argument pipes",
      "casts? = cast casts",
        "cast = opt [ cast_type! ]!",
          "opt? = ?",
          "cast_type = ... | type",
      "argument? = term argument",
      "pipes? = pipe pipes",
        "pipe = opt -> term! argument",
    "term = lambda | if | match | block | access | bundle | tuple | list | text | literal | ref",
      "if = @if term {! if_branch! more_if_branches else! }!",
        "more_if_branches? = , if_branch! more_if_branches",
        "if_branch = cond :! expr!",
          "cond = tuple | bundle",
        "else = @else =>! expr!",
      "match = @match term {! match_branch! more_match_branches default }!",
        "more_match_branches? = , match_branch! more_match_branches",
        "match_branch = [ type! ]! pattern! =>! expr!",
        "default? = @default =>! expr!",
      "block = @let { binding! more_bindings return! }!",
        "more_bindings? = , binding! more_bindings",
        "binding = pattern = expr!",
        "return = @return expr!",
      "access = access_target get more_gets produce",
        "access_target = name | ( expr )",
        "get = opt . name!",
        "more_gets? = get more_gets",
        "produce? = opt { set more_sets }!",
          "set = . name! =! expr!",
          "more_sets = , set! more_sets",
      "bundle = { } | { pair more_pairs }!",
        "more_pairs? = , pair! more_pairs",
        "pair = name : expr! | name",
      "tuple = ( ) | ( element more_elements )",
        "more_elements? = , element! more_elements",
        "element = expr",
      "list = $ ( item more_items )",
        "more_items? = , item! more_items",
        "item = expr",
      "text = Text | TxBegin first_segment more_segments TxEnd!",
        "first_segment = segment",
          "segment = segment_tag expr!",
            "segment_tag? = name : ",
        "more_segments? = next_segment more_segments",
          "next_segment = TxInner segment",
      "literal = string | int | float | bool",
        "string = String",
        "int = Dec | Hex | Oct | Bin",
        "float = Float | Exp",
        "bool = @Yes | @No",
}
