TODO

** Reactive[Struct] refactor plan (generalized projection)
type ProjRef[S,F] (Maybe[F] => (S, F));
e.g. project: &(Reactive[S], S => ProjRef[S,F]) => Reactive[F]
e.g. project: &(Maybe[S], S => ProjRef[S,F]) => ProjRef[Maybe[S],Maybe[F]]
--> &(Reactive[Maybe[S]]) => Reactive[Maybe[F]]
--> &(Reactive[W[S]]) => Reactive[V[F]] (W = WithValidation, V = ValidationState)
syntax: struct .& field => ProjRef[structType,fieldType]
   or   (struct: ProjRef[parent,struct]) .& field => ProjRef[parent,fieldType]
(no special "."/switch syntax for Reactive)  // reconsider this !!!

** Reactive[Enum] refactor plan (generalized choice)
type ChoiceRef[T,C] (&(Maybe[C]) => (T, Maybe[C]))
syntax 1: enum-or-choice/proj-ref.&(Branch) : ChoiceRef[E,Branch]
a?.&(Some).&b
e.g. choose: Reactive[E] => (ChoiceRef[E,C]) => Reactive[Maybe[C]]
syntax 2:
switch::[E] :
case B1 b1:  // b1: &E => ChoiceRef[E,B1]
    v1,
case B2 b2:  // b2: &E => ChoiceRef[E,B2]
    v2,
...,
default:
    vd,
end
// evaluates to ([v1, v2, ...], { Some vd })
type ReactiveChoiceConsumer[E, X < AnyEffect] (Reactive[E] => Computed[Maybe[X]])
ctor: (&(E) => ChoiceRef[E,B], Reactive[B] => X) => ReactiveChoiceConsumer[E,X]
e.g. choose:
(Reactive[E], (List[ReactiveChoiceConsumer[E,X]], Maybe[ReactiveChoiceConsumer[E,X]])) => X

- Atom: tree-sitter parser update

- Rx: RefEqual in DistinctWatch() (standalone new func) instead of Emit()/Update()

- Lang: consider prefix for special identifier used by compiler (e.g. @DefaultValue)

- Lang: permit anonymous record expression (currently requires explicit type)

- KMD: migrate to new numeric types, add other primitives

- Type: enum supertype: enum { ...Another, type Added; }

- KMD: data-validate only for protected/opaque types

- KMD: automatic validator call when boxing a value (box to Maybe[T])

- Data: should all value be pointer/primitive? (aka no non-primitive value type)

- Lang: Path/To/Function as namespace?

- API: revise Reactive[FlexList[T]] methods, consider methods for Reactive[Map[K,V]]

- API: to be semantic: tuple input --> record input

- API: revise resource management of files, ... (consider Disposable[T] monad)

- API: categorize API functions according to usage, corresponding types, ...

- API: separate string APIs from `api/container.go` and `lib/container/string.go`

- GUI: qtbinding C side int vs. go side int (not the same type, fix it)

- GUI: setAttributeNS() for SVG elements

- GUI: crash report window

- GUI: support: menu, toolbar, popupmenu, modal dialog

