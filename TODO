TODO

## Refinement

- Lang: string interpolation by implicit context "#{i} * #{j} = #{k}"

- Lang: CPS: unit-input lambda instead of (a,k)  // e.g. considering assert()

- Rx:
    Async: (() => T) => Async[T]
    bind: Sync => K   // sync
    bind: Async => ...  // then (await)
    zip: (Computed[A], Computed[B]) => Computed[(A,B)]  // combine
    zip: List[Computed[T]] => Computed[List[T]]  // combine-latest
    map: ((Computed[A], Computed[B]), (A,B) => T) => Computed[T]
    sample: (Source[A], Computed[B]) => Source[(A,B)]  // with-latest-from
    sample: (Source[A], (Computed[B], (A,B) => T)) => Source[T]
    // compute & sample: <= 1 update / 1 tick
    reduce -> fold

type Bus[T] protected {
    in: Sink[T],
    out: Source[T]
}

// Reactive
type Cell[T] protected {
    in: Sink[T],
    out: Computed[T]
}
// type Cell (RecordValue);
// (in,out,rx.Reactive)

\ buf := go { Reactive '' },

- FlexList: consider refactor using balanced tree + inline index

- VM: constant thunk

- Code: AST node renaming

- GUI: qtbinding C side int vs. go side int (not the same type, fix it)

- API: consider "NOT" instead of "not"

- API: consider renaming wait and tick

- GUI: setAttributeNS() for SVG elements

- Compiler: revise FuncInfo.SourceMap (try to reduce space usage)


## Type System Refactor

- Lang: only function can have bounds (type def cannot)

- Lang: consider { instance.method arg }, type A (I1, I2) { ... };
        (syntax obj.method also apply to concrete type
            (precedence field > method for concrete type))

- Lang: consider curried function as method: &(Instance) => &(In) => Out

- Lang: consider curried input as implicit input: &(Ord[T]) => &(T,T) => Bool

type I (Base1,Base2) interface { method: &(A) => B }

type Op= [T] &(T,T) => Bool;

type Op< [T] &(T,T) => Bool;

export function > :
    [T] { <: Op<[T] }
    &(T, T) => Bool
    &(a, b) => (b < a);

|None|
|Some| 1 : Maybe[Integer]
|exact:Some| 1 : Some[Integer]
|Success| 1
{ |Point| (x, y) }
| .&x |
||

// when there isn't a func or var called NAME, try to interpret NAME as |NAME|
{ Some x }
None

\ x := await foo,
bar

type type[T] protected Type;
type Type native;
type value[T] protected Value;
type Value native;
|reflect::type[Foo]|
|reflect::value| "abc"
// type assertion etc. implemented by (native) functions

- Lang: type check: (expected, ast-node, inferred) => Result[(expr, new-inferred)]

- Lang: bounds should only allow certain types (cannot include parameters)

- Lang: type/function alias Name = ref (just a name resolution interceptor)

- Lang: permit anonymous record expression (currently requires explicit type)

- Lang: fix the order randomness of field assignment of anonymous record input

- Lang: bidirectional type inference

- Lang: revise overloading rule (consider introducing input-based precedence)


## API Refactor

- API: categorize API functions according to usage, corresponding types, ...

- API: better native function names

- API: separate string APIs from `api/container.go` and `lib/container/string.go`

- API: to be semantic: tuple input --> record input

- API: revise Reactive[FlexList[T]] methods, consider methods for Reactive[Map[K,V]]

- API: revise resource management of files, ... (consider Disposable[T] monad)


## GUI Enhancement

- API: type Provider[T,A] (Computed[T], Sink[A]);

- GUI: crash report window

- GUI: support: menu, toolbar, popupmenu, modal dialog


