type Value enum {
    type Object  Map[String,Value];
    type Array   Array[Value];
    type Bool    Bool;
    type Number  Real;
    type String  String;
    type Null;
};

export function stringify:
    &(self::Value) => String
    &(v) =>
        switch v:
        case self::Object object:
            object
                . { iterate }
                . { map &(key,value) =>
                    { "#:#" ({quote key}, {self::stringify value}) } }
                . { join ',' }
                . { "{#}" },
        case self::Array array:
            array
                . { iterate }
                . { map self::stringify }
                . { join ',' }
                . { "[#]" },
        case self::Bool bool:
            switch bool:
                case Yes: 'true',
                case No:  'false',
            end,
        case self::Number number:
            { str number },
        case self::String string:
            { quote string },
        case self::Null:
            'null',
        end;

export function parse:
    &(String) => Result[self::Value,Error]
    &(input) =>
        let process := { ValueParser () },
        switch { process input }:
        case OK (value, remaining):
            if (remaining.{length} = 0):
                { OK value },
            else:
                let pos := (input.{length} - remaining.{length}),
                { NG { Error 'redundant input after parsed content'
                    . { &(msg) => { "# (at position #)" (msg, pos.{str}) } } } },
        case NG (err, remaining):
            let all := input.{length},
            let rest := remaining.{length},
            let pos: Number := if (rest > 0): (all - rest), else: (all - 1),
            { NG (err wrap &(msg) => { "# (at position #)" (msg, pos.{str}) }) },
        end;
