type ValueParserType Parser[Value,Error];

function Keyword:
    &(String) => Parser[unit,Error]
    &(keyword) => { consume (keyword, { Error { "expect '#'" keyword } }) };

function Char:
    & { accept: Array[Char] } => Parser[Char,Error]
    & { accept } =>
        let err := { Error 'unexpected character or EOF' },
        { choose (accept map &(char) =>
            ({ consume ([char].{convert}.[String], err) } map &() => char)) };

const Blank: Parser[unit,Error] :=
    { Char { accept: (' '..\t..\r..\n) } }
        . { map &() => () };

function WrappedList:[T]
    & { item:   Parser[T,Error],
        sep:    Parser[unit,Error],
        prefix: Parser[unit,Error],
        suffix: Parser[unit,Error] }
          =>    Parser[Array[T],Error]
    & { item, sep, prefix, suffix } =>
        let item := (item with-ignored Blank),
        let sep := (sep with-ignored Blank),
        | apply prefix,
        | list := apply { repeat { item, sep } },
        | apply suffix,
        { output list };

# explicit-call
const ValueParser: ValueParserType :=
    { choose [
        { throw { Error 'parser stuck' } },
        { make-lazy ObjectParser }, { make-lazy ArrayParser },
        StringParser, NumberParser, BoolParser, NullParser
    ] };

# explicit-call
const ObjectParser: ValueParserType :=
    let entry :=
        | key := apply StringParser!,
        | apply ({ Keyword ':' } with-ignored Blank),
        | value := apply { ValueParser () },
        { output (key,value) },
    let entries := { WrappedList {
        item:   entry,
        sep:    { Keyword ',' },
        prefix: { Keyword '{' },
        suffix: { Keyword '}' }
    } },
    (entries map &(entries) => { self::Object { Map entries } });

# explicit-call
const ArrayParser: ValueParserType :=
    let items := { WrappedList {
        item:   { ValueParser () },
        sep:    { Keyword ',' },
        prefix: { Keyword '[' },
        suffix: { Keyword ']' }
    } },
    (items map &(items) => { self::Array items });

const NullParser: ValueParserType :=
    { Keyword 'null' }
        . { map &() => self::Null };

const TrueParser: ValueParserType :=
    { Keyword 'true' }
        . { map &() => { self::Bool Yes } };

const FalseParser: ValueParserType :=
    { Keyword 'false' }
        . { map &() => { self::Bool No } };

const BoolParser: ValueParserType :=
    { choose [TrueParser, FalseParser] };

const NumberParser: ValueParserType :=
    | chars := apply { repeat { Char { accept: '0123456789.Ee+-' } } },
    switch { parse-real chars.{convert}.[String] }:
    case Some x:
        { output { self::Number x } },
    case None:
        { throw { Error 'invalid number' } },
    end;

const StringParser: ValueParserType :=
    (StringParser! map &(string) => { self::Value string });

const StringParser!: Parser[self::String,Error] :=
    let err := { Error 'invalid string' },
    | apply { consume ('"', err) },
    &(input) =>
        let proceed: rec
            &(Number) => Maybe[Number] :=
            &(pos) =>
                | prev := get
                    if (pos > 0): (input at (pos - 1)), else: { Some `" },
                | this := get
                    (input at pos),
                if ((this = `") and (prev != `\)):
                    { Some pos },
                else:
                    { proceed (pos + 1) },
        switch { proceed 0 }:
        case Some end:
            let raw := (input substr-view (0, end)).[String],
            switch { unquote raw }:
            case Some content:
                let value := { self::String! content },
                let input := (input substr-view ((end + 1), input.{length})),
                { Success (value, input) },
            case None:
                { Failure (err, input) },
            end,
        case None:
            { Failure (err, input) },
        end;
