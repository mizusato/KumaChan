// TODO: rewrite this file using parser combinators
type ParserState {
    input:   String,
    pos:     Number,
    status:  ParserStatus
};
type ParserStatus enum {
    type ParseValue;
    type ParseObjectKey   { entries: Seq[(String,Value)] };
    type ParseObjectValue { entries: Seq[(String,Value)], key: String };
    type ParseObjectNext  { entries: Seq[(String,Value)] };
    type ParseArray       { items: Seq[Value] };
    type ParseArrayNext   { items: Seq[Value] };
    type ParseNumber { begin: Number };
    type ParseString { begin: Number };
    type ParseNull   { begin: Number };
    type ParseTrue   { begin: Number };
    type ParseFalse  { begin: Number };
    type ParseBlanks { saved: Value };
};
const Blanks: String
    str [\n, \t, ^ ];
const NumberChars: String
    '0123456789.Ee+-';
const TrueChars: String
    'true';
const FalseChars: String
    'false';
const NullChars: String
    'null';

function parse: (&(String)(Result[Value,String]))
    (&(str)(
        let initial-state := ParserState {
            input:  str,
            pos:    0,
            status: ParseValue
        },
        switch (parse initial-state):
        case OK (val, _):
            OK val,
        case NG (err):
            NG err,
        end
    ));

function parse: (&(ParserState)(Result[(Value,Number),String]))
    (&(state)(
        let {input,pos,status} := state,
        let go: (&(Number,ParserStatus)(Result[(Value,Number),String]))
            := (&(next-pos, next-status)(
                let result := parse (ParserState {
                    input,
                    pos:    next-pos,
                    status: next-status
                }),
                switch result:
                case OK (value, pos):
                    parse (ParserState {
                        input, pos,
                        status: ParseBlanks { saved: value }
                    }),
                case NG err:
                    NG err,
                end
            )),
        let go-next: (&(ParserStatus)(Result[(Value,Number),String]))
            := (&(next-status)(go (+ 1 pos) next-status)),
        let go-current: (&(ParserStatus)(Result[(Value,Number),String]))
            := (&(next-status)(go pos next-status)),
        let scan-chars: (&(Array[Char],Number,Value)(Result[(Value,Number),String]))
            := (&(chars, begin, val)(
                let i := $(pos - begin),
                if $(i = (chars.length)):
                    OK (val, pos),
                else:
                    switch $(input at pos):
                    case N/A:
                        NG 'unexpected end of input',
                    case Just char:
                        let expected := $(chars at! i),
                        if $(char = expected):
                            go-next status,
                        else:
                            NG ("expect char # at #, got #"
                                (str expected) (str pos) (str char)),
                    end
            )),
        switch status:
        case ParseValue:
            switch $(input at pos):
            case N/A:
                NG 'unexpected end of input',
            case Just char:
                if $(Blanks contains char):
                    go-next ParseValue,
                elif $(char = ^{):
                    go-next (ParseObjectKey { entries: nil() }),
                elif $(char = ^[):
                    go-next (ParseArray { items: nil() }),
                elif $(char = ^"):
                    go-next (ParseString { begin: $(pos + 1) }),
                elif $(NumberChars contains char):
                    go-current (ParseNumber { begin: pos }),
                elif $(char = ^t):
                    go-current (ParseTrue { begin: pos }),
                elif $(char = ^f):
                    go-current (ParseFalse { begin: pos }),
                elif $(char = ^n):
                    go-current (ParseNull { begin: pos }),
                else:
                    NG ("unexpected char # at #" (str char) (str pos)),
            end,
        case ParseObjectKey {entries}:
            switch $(input at pos):
            case N/A:
                NG 'unexpected end of input',
            case Just char:
                if $(char = ^}):
                    OK ((Self::Object (create-map:[Value] [])), $(pos + 1)),
                elif $(Blanks contains char):
                    go-next status,
                elif $(char = ^"):
                    switch (go-next (ParseString { begin: $(pos + 1) })):
                    case OK (key-val, pos):
                        switch key-val:
                        case Self::String (json-str):
                            let key := (:String: json-str),
                            switch $(input at pos):
                            case N/A:
                                NG 'unexpected end of input',
                            case Just char:
                                if $(char = ^:):
                                    go ($(pos + 1), ParseObjectValue {
                                        entries, key
                                    }),
                                else:
                                    NG ("colon expected at #" (str pos)),
                            end,
                        default:
                            panic 'impossible branch',
                        end,
                    case NG (err):
                        NG err,
                    end,
                else:
                    NG ("double quote expected at #" (str pos)),
            end,
        case ParseObjectValue {entries,key}:
            switch (go-current ParseValue):
            case OK (val, pos):
                go (pos, ParseObjectNext {
                    entries: $((key,val) cons entries)
                }),
            case NG (err):
                NG err,
            end,
        case ParseObjectNext {entries}:
            switch $(input at pos):
            case N/A:
                NG 'unexpected end of input',
            case Just char:
                if $(char = ^,):
                    go-next (ParseObjectKey { entries }),
                elif $(char = ^}):
                    let entries-array := (collect entries),
                    OK ((Self::Object (create-map entries-array)), $(pos + 1)),
                else:
                    NG ("unexpected char # at #" (str char) (str pos)),
            end,
        case ParseArray {items}:
            switch $(input at pos):
            case N/A:
                NG 'unexpected end of input',
            case Just char:
                if $(char = ^]):
                    OK ((Self::Array []), $(pos + 1)),
                else:
                    switch (go-current ParseValue):
                    case OK (val, pos):
                        go (pos, ParseArrayNext {
                            items: $(val cons items)
                        }),
                    case NG err:
                        NG err,
                    end,
            end,
        case ParseArrayNext {items}:
            switch $(input at pos):
            case N/A:
                NG 'unexpected end of input',
            case Just char:
                if $(char = ^,):
                    go-next (ParseArray { items }),
                elif $(char = ^]):
                    let reversed := (collect items),
                    let array := (reverse reversed),
                    OK ((Self::Array array), $(pos + 1)),
                else:
                    NG ("unexpected char # at #" (str char) (str pos)),
            end,
        case ParseString {begin}:
            switch $(input at pos):
            case N/A:
                NG 'unexpected end of input',
            case Just char:
                if $(char = ^"):
                    let prev := $(input at! $(pos - 1)),
                    if $(prev != ^\):
                        let raw := (str (input.slice begin pos)),
                        switch (unquote raw):
                        case Just str:
                            OK ((Self::String str), $(pos + 1)),
                        case N/A:
                            NG ("invalid string at #" (str begin)),
                        end,
                    else:
                        go-next status,
                else:
                    go-next status,
            end,
        case ParseNumber {begin}:
            let got-number: (&()(Result[(Value,Number),String]))
                := (&(_)(
                    let raw := (str (input.slice begin pos)),
                    switch (parse-float raw):
                    case Just x:
                        OK ((Self::Number x), pos),
                    case N/A:
                        NG ("invalid number at #" (str begin)),
                    end
                )),
            switch $(input at pos):
            case Just char:
                if $(NumberChars contains char):
                    go-next status,
                else:
                    got-number (),
            case N/A:
                got-number (),
            end,
        case ParseTrue {begin}:
            (scan-chars TrueChars begin (Boolean Yes)),
        case ParseFalse {begin}:
            (scan-chars FalseChars begin (Boolean No)),
        case ParseNull {begin}:
            (scan-chars NullChars begin (Null)),
        case ParseBlanks {saved}:
            switch $(input at pos):
            case Just char:
                if $(Blanks contains char):
                    go-next (ParseBlanks { saved }),
                else:
                    OK (saved, pos),
            case N/A:
                OK (saved, pos),
            end,
        end
    ));
