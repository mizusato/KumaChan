// TODO: remove unused functions in this module and merge this module into UI

type Object      native;  // qt.Object
type Signal[+T]  protected Action*[T];
type Event[+T]   protected Action*[T];
type Static[+O < Object]  opaque O;

type Icon native;

type EventResized {
    width:  Number,
    height: Number
};
type EventClosed {};

function get-property[O < Object, T]: ( &(Static[O],String,String) T )
    native 'qt-get-property';

function set-property[T]: ( &(Object,String,String,T) Action )
    native 'qt-set-property';

function signal [O < Object, T]:
    ( &(O,String,(&(Static[O])(T))) Signal[T] )
    native 'qt-signal';

function signal [T]:
    ( &(Object,String) Signal[unit] )
    native 'qt-signal-no-payload';

function event[E]: ( &(Object,String,Bool) Event[E] )
    native 'qt-event';

export function bind [Obj < Object, T]:
    ( &(Obj, Reactive[T], (&(Obj)(Signal[T])), (&(Obj,T)(Action)))
        Action )
    ( &(obj, @value, get, set)
        let @get := obj.get.concat-map (&(value)(@value.update (&(_)(value)))),
        let @set := @value.watch.concat-map (&(value)(obj.set value)),
        (merge [@get, @set]).forever
    );

export function listen[T]: ( &(Event[T],(&(T)(Action))) Action )
    ( &(ev,f)
        ev  | merge-map (&(payload)(f payload))
            | forever
    );

export function resized: ( &(Object) Event[EventResized] )
    (&(object)(event object 'resized' No));

export function closed: ( &(Object) Event[EventClosed] )
    (&(object)(event object 'closed' Yes));
