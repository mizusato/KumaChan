type Decorator
    &(Component) => Component;

export function with:
    &(Component, Decorator) => Component
    &(cpt, f) => { f(cpt) };

export function with:
    &(Component, Array[Decorator]) => Component
    &(cpt, @f) => cpt.{apply-all @f.{iterate}};

export function with:[T]
    &((&(T) => Component), Decorator) => (&(T) => Component)
    &(ctor, f) => (&(arg) => { f { ctor(arg) } });

export function with:[T]
    &((&(T) => Component), Array[Decorator]) => (&(T) => Component)
    &(ctor, @f) => (&(arg) => {ctor(arg)}.{apply-all @f.{iterate}});

export function RenderCond:
    &(Computed[Bool]) => Decorator
    &(@render) => &(cpt) =>
        & render := switch-map @render,
        if render:
            cpt,
        else:
            Empty;

export function ShowCond:
    &(Computed[Bool]) => Decorator
    &(@show) => &(@node) =>
        & (node, show) := computed (@node, @show),
        if show:
            node,
        else:
            (node with { create-styles [('display','none')] });

export function Style:
    &(Array[String]) => Decorator
    &(class-list) => &(@node) =>
        let class := (class-list join ' '),
        (@node map &(node) => (node with { create-attrs [('class',class)] }));

export function Style:
    &(Computed[Array[String]]) => Decorator
    &(@class-list) => &(@node) =>
        & (class-list, node) := computed (@class-list, @node),
        let class := (class-list join ' '),
        (node with { create-attrs [('class',class)] });

export function InlineStyle:
    &(Array[(String,String)]) => Decorator
    &(rules) => &(@node) =>
        & node := map @node,
        (node with { create-styles rules });

export function InlineStyle:
    &(Computed[Array[(String,String)]]) => Decorator
    &(@rules) => &(@node) =>
        & (rules, node) := computed (@rules, @node),
        (node with { create-styles rules });

export function Event:
    &(String,EventPayloadConsumer) => Decorator
    &(name,consumer) => &(@node) =>
        let handler := consumer.{convert}.[EventHandler],
        & node := map @node,
        (node with { create-events [(name,handler)] });

export function Focusable:
    &() => Decorator
    &() => &(@node) =>
        & node := map @node,
        (node with { create-attrs [('tabindex','0')] });

export function Autofocus:
    &() => Decorator
    &() => &(@node) =>
        & node := map @node,
        (node with { create-attrs [('webuiAutofocus','webuiAutofocus')] });

export function EnableCond:
    &(Computed[Bool]) => Decorator
    &(@enabled) => &(@node) =>
        & (enabled, node) := computed (@enabled, @node),
        if enabled:
            node,
        else:
            (node with { create-attrs [('disabled', 'disabled')] });

