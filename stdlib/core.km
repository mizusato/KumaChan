module Core;

// Basic Types
type Bit    native 'Bit';
type Byte   native 'Byte';
type Word   native 'Word';
type Dword  native 'Dword';
type Qword  native 'Qword';
type Int    native 'Int';

// Collection Types
type Bytes     native 'Bytes';
type Map(K,V)  native 'Map';
type Stack(T)  native 'Stack';
type Heap(T)   native 'Heap';
type List(T)   native 'List';

// Effect Type
type Effect(T,E)  native 'Effect';

// Basic Derived Types
type Int64   [Qword];
type Uint64  [Qword];
type Int32   [Dword];
type Uint32  [Dword];
type Int16   [Word];
type Uint16  [Word];
type Int8    [Byte];
type Uint8   [Byte];
type Float64       [Qword];
opaque type Float  [Float64];
type Char    [Dword];
type String  [List(Char)];

// Basic Sum Types
type Bool union {
    type Yes [];
    type No [];
};
type Maybe(T) union {
    type Just [T];
    type Null [];
};
type Result(T,E) union {
    type OK [T];
    type NG [E];
};

// Arithmetic Functions
// Integer
global + := (&Int. &Int.Int)  native 'int-plus';
global - := (&Int. &Int.Int)  native 'int-minus';
global minus := (&Int.Int)    native 'int-minus-unary';
global * := (&Int. &Int.Int)  native 'int-times';
global / := (&Int. &Int.Int)  native 'int-divide';
global % := (&Int. &Int.Int)  native 'int-modulo';
global ^ := (&Int. &Int.Int)  native 'int-power';
global divmod := (&Int. &Int.[Int,Int])  native 'int-divmod';
// Floating Point Number
global + := (&Float. &Float.Float)  native 'float-plus';
global - := (&Float. &Float.Float)  native 'float-minus';
global minus := (&Float.Float)      native 'float-minus-unary';
global * := (&Float. &Float.Float)  native 'float-times';
global / := (&Float. &Float.Float)  native 'float-divide';
global % := (&Float. &Float.Float)  native 'float-modulo';
global ^ := (&Float. &Float.Float)  native 'float-power';
global divmod := (&Float. &Float.[Float,Float])  native 'float-divmod';

global just(T) := (&T.Maybe(T)) &t.[(...)(Just(T)) t];
global nothing(T) := (&[].Maybe(T)) &[].[(...)(Null) []];
global maybe(A,B) := (&[&A.B].&Maybe(A).Maybe(B))
&f.&a. [(...) match [a] {
    [Just(A)] a: (Just(B)) f a,
    [Null]: (Null) []
}];

const EmptyList(T) := (List(T)) native 'empty-list';
global concat(T) := (&[List(T),List(T)].List(T)) native 'list-concat';
global append(T) := (&T.&List(T).List(T)) native 'list-append';
global prepend(T) := (&T.&List(T).List(T)) native 'list-prepend';
global shift(T) := (&List(T).[Maybe(T),List(T)]) native 'list-shift';
global pop(T) := (&List(T).[List(T),Maybe(T)]) native 'list-pop';
global map(A,B) := (&[&A.B].&List(A).List(B))  native 'list-map';
global filter(T) := (&[&T.Bool].&List(T).List(T)) native 'list-filter';
global reduce(I,A) := (&[A,&[A,I].A].&List(I).A) native 'list-reduce';

const EmptyStack(T) := (Stack(T)) native 'empty-stack';
global pop(T) := (&Stack(T).[Maybe(T),Stack(T)])  native 'stack-pop';
global push(T) := (&T.&Stack(T).Stack(T))  native 'stack-push';
global map(A,B) := (&[&A.B].&Stack(A).Stack(B))
&f.&stack. let {
    [top, rest] := pop stack,
    return match [top] {
        [Just(A)] [top]: rest | map f | push f top,
        [Null]: EmptyStack(B)
    }
};
global filter(T) := (&[&T.Bool].&Stack(T).Stack(T))
&ok.&stack. let {
    [top, rest] := pop stack,
    ok-rest := rest | filter ok,
    return match [top] {
        [Just(T)] [top]: if { [ok top]? [ok-rest | push top]: ok-rest },
        [Null]: EmptyStack(T)
    }
};
global reduce(I,A) := (&[A,&[A,I].A].&Stack(I).A)
&[value, f].&stack. let {
    [top, rest] := pop stack,
    return match [top] {
        [Just(I)] [top]: rest | reduce [f [value, top], f],
        [Null]:  EmptyStack(I)
    }
};