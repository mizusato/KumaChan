module Core;

// Basic Types
type Bit    native;
type Byte   native;
type Word   native;
type Dword  native;
type Qword  native;
type Int    native;

// Container Types
type Bytes     native;
type String    native;
type Seq[T]    native;
type Array[T]  native;
type Heap[T]   native;
type Set[T]    native;
type Map[K,V]  native;

// Effect Type
type Effect[T,E]  native;

// Basic Derived Types
type Int64   (Qword);
type Uint64  (Qword);
type Int32   (Dword);
type Uint32  (Dword);
type Int16   (Word);
type Uint16  (Word);
type Int8    (Byte);
type Uint8   (Byte);
type Char    (Dword);
type Float64       (Qword);
opaque type Float  (Float64);

// Basic Sum Types
type Bool union {
    type Yes ();
    type No  ();
};
type Maybe[T] union {
    type Just(T);
    type Nothing();
};
type Result[T,E] union {
    type OK(T);
    type NG(E);
};

// Singly-Linked List
type List[T] union {
    type Nil  ();
    type Cons (T, List[T]);
};

global map[A,B] := [&(&A.B).&Maybe[A].Maybe[B]]
&fab. &maybe-a. match(maybe-a) {
    case Just a: Just fab(a),
    case Null  : Null()
};
global map[A,B] := [&(&A.B).&List[A].List[B]]
&fab. &list-a. match(list-a) {
    case Cons(a, rest): Cons(fab(a), (map fab)(rest)),
    case Nil: Nil()
};

global filter[T] := [&(&T.Bool).&List[T].List[T]]
&pred. &list. match(list) {
    case Cons(item, rest): if { pred(item)? Cons(item, rest): rest },
    case Nil: Nil()
};

global reduce[T,A] := [&(A, &(A, T).A).&List[T].List[T]]
&(init, reducer). &list. match(list) {
    case Cons(item, rest): rest | reduce(reducer(init, item), reducer),
    case Nil: Nil()
};
