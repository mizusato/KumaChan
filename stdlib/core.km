module Core;


/**
 *  IMPORTANT: The following type definitions should be kept consistent
 *             with the `stdlib.go` file.
 */

// Basic Types
type Bit     native;  // bool
type Byte    native;  // uint8, int8
type Word    native;  // uint16, int16
type Dword   native;  // uint32, int32
type Qword   native;  // uint64, int64, float64
type Number  native;  // uint
type Int     native;  // *big.Int

// Container Types
type Seq[T]    native;  // container.Seq
type Array[T]  native;  // []T, container.Array
type Heap[T]   native;  // container.Heap
type Set[T]    native;  // container.Set
type Map[K,V]  native;  // container.Map

// Effect Types
type Effect*[T,E]  native;  // rx.Effect       (Observable<T,E>)
type Effect[T,E]   protected Effect*[T,E];  // (Promise<T,E>)
type NoExcept*[T]  native;  // rx.Effect       (Observable<T>)
type NoExcept[T]   protected NoExcept*[T];  // (Promise<T>)

// Mutable Containers
type Source[T]   native;  // rx.Source
type Sink[T]     protected Source[T];  // rx.Sink
type Mutable[T]  native;  // rx.Cell
type List[T]     native;  // rx.List
type HashMap[T]  native;  // rx.Map

// Fixed Integer Types
type Int64   protected Qword;
type Uint64  protected Qword;
type Int32   protected Dword;
type Uint32  protected Dword;
type Int16   protected Word;
type Uint16  protected Word;
type Int8    protected Byte;
type Uint8   protected Byte;

// Basic Boxed Types
type Float64  protected Qword;
type Float    protected Float64;  // float64 with NaN and Infinity excluded
type Complex  (Float, Float);
type Char     Uint32;  // rune
type Range    protected (Number, Number);  // left-close right-open interval
type String   protected Array[Char];  // []rune
type Bytes    protected Array[Byte];  // []byte

// Basic Sum Types
type Bool union {
    type Yes;
    type No;
};
type Maybe[T] union {
    type Just[T] T;
    type N/A;
};
type Result[T,E] union {
    type OK[T] T;
    type NG[E] E;
};
type Ordering union {
    type <<;
    type ==;
    type >>;
};

// Debugging Types
type Debug[T]  protected T;
type Never[T]  protected T;

// Debugging Functions (With Side Effects)
public function trace[T] {
    lambda T Debug[T]:
    native 'trace'
};
public function panic[T] {
    lambda String Never[T]:
    native 'panic'
};

// Logic Macros
public macro not(p)    := ~Bool(if p: No, else: Yes);
public macro and(p, q) := ~Bool(if p: (if q: Yes, else: No), else: No);
public macro  or(p, q) := ~Bool(if p: Yes, else: (if q: Yes, else: No));

// Baisc Arithmetic Functions
public function + { lambda (Int,Int) Int:  native '+Int' };
public function - { lambda (Int,Int) Int:  native '-Int' };
public function * { lambda (Int,Int) Int:  native '*Int' };
public function quorem { lambda (Int,Int) (Int,Int):  native 'quorem' };
public function divmod { lambda (Int,Int) (Int,Int):  native 'divmod' };
public function - {
    lambda Int   Int:
    lambda  n  $(0 - n)
};
public function / {
    lambda (Int,Int) Int:
    lambda (a, b)    let (q, _) := quorem(a, b), return q
};
public function % {
    lambda (Int,Int) Int:
    lambda (a, b)    let (_, r) := quorem(a, b), return r
};
public function div {
    lambda (Int,Int) Int:
    lambda (a, b)    let (q, _) := divmod(a, b), return q
};
public function mod {
    lambda (Int,Int) Int:
    lambda (a, b)    let (_, r) := divmod(a, b), return r
};
public function ** {
    lambda (Int,Int) Int:
    lambda (n, p)
        let rec: pow := [lambda (Int,Int,Int) Int]
                        power-by-squaring (pow),
        return pow (1, n, p)
};
private macro power-by-squaring (recursive-call)
:= lambda(t, n, p)
    switch $(p <> 0) {
    case <<:
        panic 'taking negative power of a Int value is not supported',
    case ==:
        if $(n = 0):
            panic 'cannot evaluate 0 to the power of 0',
        else:
            t,
    case >>:
        if $(p = 1):
            $(t * n),
        else:
            let (q, r) := $(p divmod 2),
                square := $(n * n),
            return
                if $(r = 1):
                    recursive-call ($(t * n), square, q),
                else:
                    recursive-call (t, square, q)
    };
public function + { lambda (Number, Number) Number:  native '+Number' };
public function - { lambda (Number, Number) Number:  native '-Number' };
public function * { lambda (Number, Number) Number:  native '*Number' };
public function / { lambda (Number, Number) Number:  native '/Number' };
public function % { lambda (Number, Number) Number:  native '%Number' };
public function + { lambda (Float, Float) Float:  native '+Float' };
public function - { lambda (Float, Float) Float:  native '-Float' };
public function * { lambda (Float, Float) Float:  native '*Float' };
public function / { lambda (Float, Float) Float:  native '/Float' };
public function % { lambda (Float, Float) Float:  native '%Float' };
public function - {
    lambda Float   Float:
    lambda   x   $(0.0 - x)
};
public function + { lambda (Int8, Int8) Int8:  native '+Int8' };
public function - { lambda (Int8, Int8) Int8:  native '-Int8' };
public function * { lambda (Int8, Int8) Int8:  native '*Int8' };
public function / { lambda (Int8, Int8) Int8:  native '/Int8' };
public function % { lambda (Int8, Int8) Int8:  native '%Int8' };
public function - {
    lambda Int8   Int8:
    lambda  n   $(0 - n)
};
public function + { lambda (Uint8, Uint8) Uint8:  native '+Uint8' };
public function - { lambda (Uint8, Uint8) Uint8:  native '-Uint8' };
public function * { lambda (Uint8, Uint8) Uint8:  native '*Uint8' };
public function / { lambda (Uint8, Uint8) Uint8:  native '/Uint8' };
public function % { lambda (Uint8, Uint8) Uint8:  native '%Uint8' };
public function - {
    lambda Uint8  Uint8:
    lambda   n   $(0 - n)
};
public function + { lambda (Int16, Int16) Int16:  native '+Int16' };
public function - { lambda (Int16, Int16) Int16:  native '-Int16' };
public function * { lambda (Int16, Int16) Int16:  native '*Int16' };
public function / { lambda (Int16, Int16) Int16:  native '/Int16' };
public function % { lambda (Int16, Int16) Int16:  native '%Int16' };
public function - {
    lambda Int16  Int16:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint16, Uint16) Uint16:  native '+Uint16' };
public function - { lambda (Uint16, Uint16) Uint16:  native '-Uint16' };
public function * { lambda (Uint16, Uint16) Uint16:  native '*Uint16' };
public function / { lambda (Uint16, Uint16) Uint16:  native '/Uint16' };
public function % { lambda (Uint16, Uint16) Uint16:  native '%Uint16' };
public function - {
    lambda Uint16  Uint16:
    lambda   n    $(0 - n)
};
public function + { lambda (Int32, Int32) Int32:  native '+Int32' };
public function - { lambda (Int32, Int32) Int32:  native '-Int32' };
public function * { lambda (Int32, Int32) Int32:  native '*Int32' };
public function / { lambda (Int32, Int32) Int32:  native '/Int32' };
public function % { lambda (Int32, Int32) Int32:  native '%Int32' };
public function - {
    lambda Int32  Int32:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint32, Uint32) Uint32:  native '+Uint32' };
public function - { lambda (Uint32, Uint32) Uint32:  native '-Uint32' };
public function * { lambda (Uint32, Uint32) Uint32:  native '*Uint32' };
public function / { lambda (Uint32, Uint32) Uint32:  native '/Uint32' };
public function % { lambda (Uint32, Uint32) Uint32:  native '%Uint32' };
public function - {
    lambda Uint32  Uint32:
    lambda   n    $(0 - n)
};
public function + { lambda (Int64, Int64) Int64:  native '+Int64' };
public function - { lambda (Int64, Int64) Int64:  native '-Int64' };
public function * { lambda (Int64, Int64) Int64:  native '*Int64' };
public function / { lambda (Int64, Int64) Int64:  native '/Int64' };
public function % { lambda (Int64, Int64) Int64:  native '%Int64' };
public function - {
    lambda Int64  Int64:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint64, Uint64) Uint64:  native '+Uint64' };
public function - { lambda (Uint64, Uint64) Uint64:  native '-Uint64' };
public function * { lambda (Uint64, Uint64) Uint64:  native '*Uint64' };
public function / { lambda (Uint64, Uint64) Uint64:  native '/Uint64' };
public function % { lambda (Uint64, Uint64) Uint64:  native '%Uint64' };
public function - {
    lambda Uint64  Uint64:
    lambda   n    $(0 - n)
};

// Advanced Arithmetic Functions
public function floor! { lambda Float Float:  native 'floor' };
public function  ceil! { lambda Float Float:  native 'ceil' };
public function round! { lambda Float Float:  native 'round' };
public function ** { lambda (Float,Float) Float:  native 'real-**' };
public function sqrt { lambda Float Float:  native 'real-sqrt' };
public function cbrt { lambda Float Float:  native 'real-cbrt' };
public function  exp { lambda Float Float:  native 'real-exp' };
public function   ln { lambda Float Float:  native 'real-log' };
public function  sin { lambda Float Float: native 'real-sin' };
public function  cos { lambda Float Float: native 'real-cos' };
public function  tan { lambda Float Float: native 'real-tan' };
public function asin { lambda Float Float: native 'real-asin' };
public function acos { lambda Float Float: native 'real-acos' };
public function atan { lambda Float Float: native 'real-atan' };
public function atan2 { lambda { y: Float, x: Float } Float:  native 'atan2' };
public function log {
    lambda { base: Float, x: Float } Float:
    lambda {base,x} $((ln x) / (ln base))
};
public function log2 {
    lambda Float Float:
    lambda x (log { base: 2.0, x })
};
public function log10 {
    lambda Float Float:
    lambda x (log { base: 10.0, x })
};
private const  i := [Complex] Complex(0.0, 1.0);
private const _1 := [Complex] Complex(1.0, 0.0);
private macro re-im-> (z, expr) := (let (re, im) := z, return expr);
public function re! {
    lambda Complex Float:
    lambda (re, _) re
};
public function im! {
    lambda Complex Float:
    lambda (_, im) im
};
public function conj! {
    lambda Complex Complex:
    lambda (re, im) (Complex (re, (- im)))
};
public function arg! {
    lambda Complex Float:
    lambda (re, im) (atan2 { y: im, x: re })
};
public function norm! {
    lambda Complex Float:
    lambda (re, im) (sqrt $($(re * re) + $(im * im)))
};
public function polar! {
    lambda { norm: Float, arg: Float } Complex:
    lambda { norm, arg }
        if $(norm >= 0.0):
            Complex ( $(norm * (cos arg)), $(norm * (sin arg)) ),
        else:
            panic 'invalid input: negative norm'
};
public function polar! {
    lambda Float Complex:
    lambda  arg  polar! { norm: 1.0, arg }
};
public function + {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (r1, i1) := z1,
            (r2, i2) := z2,
        return Complex ($(r1 + r2), $(i1 + i2))
};
public function + {
    lambda (Float,Complex) Complex:
    lambda (x, z) (z | re-im-> Complex ($(x + re), im))
};
public function + {
    lambda (Complex,Float) Complex:
    lambda (z, x) $(x + z)
};
public function - {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (r1, i1) := z1,
            (r2, i2) := z2,
        return Complex ($(r1 - r2), $(i1 - i2))
};
public function - {
    lambda (Float,Complex) Complex:
    lambda (x, z) $(x + (- z))
};
public function - {
    lambda (Complex,Float) Complex:
    lambda (z, x) $(z + (- x))
};
public function * {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (a, b) := z1,
            (c, d) := z2,
        return Complex ( $($(a * c) - $(b * d)), $($(a * d) + $(b * c)) )
};
public function * {
    lambda (Float,Complex) Complex:
    lambda (x, z) (z | re-im-> Complex ($(x * re), $(x * im)))
};
public function * {
    lambda (Complex,Float) Complex:
    lambda (z, x) $(x * z)
};
public function / {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (a, b) := z1,
            (c, d) := z2,
               u   := Complex ( $($(a * c) + $(b * d)), $($(b * c) - $(a * d)) ),
               v   := Complex ( $(1.0 / $($(c * c) + $(d * d))), 0.0 ),
        return $(u * v)
};
public function / {
    lambda (Float,Complex) Complex:
    lambda (x, z) $((Complex (x, 0.0)) / z)
};
public function / {
    lambda (Complex,Float) Complex:
    lambda (z, x) (z | re-im-> Complex ($(re / x), $(im / x)))
};
public function - {
    lambda Complex Complex:
    lambda (re, im) (Complex ((- re), (- im)))
};
public function exp {
    lambda Complex Complex:
    lambda (re, im) (polar! { norm: exp(re), arg: im })
};
public function ln {
    lambda Complex Complex:
    lambda    z    Complex((ln norm! z), (arg! z))
};
public function sin {
    lambda Complex Complex:
    lambda    z    $( $((exp $(i * z)) - (exp $((- i) * z))) / $(2.0 * i) )
};
public function cos {
    lambda Complex Complex:
    lambda    z    $( $((exp $(i * z)) + (exp $((- i) * z))) / $(2.0 * _1) )
};
public function tan {
    lambda Complex Complex:
    lambda    z    $((sin z) / (cos z))
};
public function asin {
    lambda Complex Complex:
    lambda    z    $((- i) * (ln $( $(i * z) + (sqrt $(1.0 - $(z * z))) )))
};
public function acos {
    lambda Complex Complex:
    lambda    z    $((- i) * (ln $( z + (sqrt $($(z * z) - 1.0)) )))
};
public function atan {
    lambda Complex Complex:
    lambda    z    $($(i / 2.0) * (ln $($(i + z) / $(i - z))))
};
public function sqrt {
    lambda Complex Complex:
    lambda    z    (polar! { norm: (sqrt norm! z), arg: $((arg! z) / 2.0) })
};
public function cbrt {
    lambda Complex Complex:
    lambda    z    (polar! { norm: (cbrt norm! z), arg: $((arg! z) / 3.0) })
};

// Comparison Functions & Macros
public macro != (a, b) := not $(a = b);
public macro  > (a, b) := $(b < a);
public macro <= (a, b) := not $(a > b);
public macro >= (a, b) := not $(a < b);
public function  = { lambda (String,String) Bool:      native '=String' };
public function  < { lambda (String,String) Bool:      native '<String' };
public function <> { lambda (String,String) Ordering:  native '<>String' };
public function  = { lambda (Int,Int) Bool:      native '=Int' };
public function  < { lambda (Int,Int) Bool:      native '<Int' };
public function <> { lambda (Int,Int) Ordering:  native '<>Int' };
public function  = { lambda (Number,Number) Bool:      native '=Number' };
public function  < { lambda (Number,Number) Bool:      native '<Number' };
public function <> { lambda (Number,Number) Ordering:  native '<>Number' };
public function  = { lambda (Float,Float) Bool:      native '=Float' };
public function  < { lambda (Float,Float) Bool:      native '<Float' };
public function <> { lambda (Float,Float) Ordering:  native '<>Float' };
public function  = { lambda (Int8,Int8) Bool:      native '=Int8' };
public function  < { lambda (Int8,Int8) Bool:      native '<Int8' };
public function <> { lambda (Int8,Int8) Ordering:  native '<>Int8' };
public function  = { lambda (Uint8,Uint8) Bool:      native '=Uint8' };
public function  < { lambda (Uint8,Uint8) Bool:      native '<Uint8' };
public function <> { lambda (Uint8,Uint8) Ordering:  native '<>Uint8' };
public function  = { lambda (Int16,Int16) Bool:      native '=Int16' };
public function  < { lambda (Int16,Int16) Bool:      native '<Int16' };
public function <> { lambda (Int16,Int16) Ordering:  native '<>Int16' };
public function  = { lambda (Uint16,Uint16) Bool:      native '=Uint16' };
public function  < { lambda (Uint16,Uint16) Bool:      native '<Uint16' };
public function <> { lambda (Uint16,Uint16) Ordering:  native '<>Uint16' };
public function  = { lambda (Int32,Int32) Bool:      native '=Int32' };
public function  < { lambda (Int32,Int32) Bool:      native '<Int32' };
public function <> { lambda (Int32,Int32) Ordering:  native '<>Int32' };
public function  = { lambda (Uint32,Uint32) Bool:      native '=Uint32' };
public function  < { lambda (Uint32,Uint32) Bool:      native '<Uint32' };
public function <> { lambda (Uint32,Uint32) Ordering:  native '<>Uint32' };
public function  = { lambda (Int64,Int64) Bool:      native '=Int64' };
public function  < { lambda (Int64,Int64) Bool:      native '<Int64' };
public function <> { lambda (Int64,Int64) Ordering:  native '<>Int64' };
public function  = { lambda (Uint64,Uint64) Bool:      native '=Uint64' };
public function  < { lambda (Uint64,Uint64) Bool:      native '<Uint64' };
public function <> { lambda (Uint64,Uint64) Ordering:  native '<>Uint64' };

// Bitwise Operation Functions
public function AND { lambda (Bit,Bit) Bit:  native '&Bit' };
public function  OR { lambda (Bit,Bit) Bit:  native '|Bit' };
public function NOT { lambda Bit Bit:        native '~Bit' };
public function AND { lambda (Byte,Byte) Byte:  native '&Byte' };
public function  OR { lambda (Byte,Byte) Byte:  native '|Byte' };
public function NOT { lambda Byte Byte:         native '~Byte' };
public function XOR { lambda (Byte,Byte) Byte:  native '^Byte' };
public function SHL { lambda (Byte,Number) Byte:  native '<<Byte' };
public function SHR { lambda (Byte,Number) Byte:  native '>>Byte' };
public function AND { lambda (Word,Word) Word:  native '&Word' };
public function  OR { lambda (Word,Word) Word:  native '|Word' };
public function NOT { lambda Word Word:         native '~Word' };
public function XOR { lambda (Word,Word) Word:  native '^Word' };
public function SHL { lambda (Word,Number) Word:  native '<<Word' };
public function SHR { lambda (Word,Number) Word:  native '>>Word' };
public function AND { lambda (Dword,Dword) Dword:  native '&Dword' };
public function  OR { lambda (Dword,Dword) Dword:  native '|Dword' };
public function NOT { lambda Dword Dword:          native '~Dword' };
public function XOR { lambda (Dword,Dword) Dword:  native '^Dword' };
public function SHL { lambda (Dword,Number) Dword:   native '<<Dword' };
public function SHR { lambda (Dword,Number) Dword:   native '>>Dword' };
public function AND { lambda (Qword,Qword) Qword:  native '&Qword' };
public function  OR { lambda (Qword,Qword) Qword:  native '|Qword' };
public function NOT { lambda Qword Qword:          native '~Qword' };
public function XOR { lambda (Qword,Qword) Qword:  native '^Qword' };
public function SHL { lambda (Qword,Number) Qword:   native '<<Qword' };
public function SHR { lambda (Qword,Number) Qword:   native '>>Qword' };

// Range Operation Functions
public function range! {
    lambda (Number,Number) Range:
    lambda (l, r)
        if $(l <= r):
            Range(l, r),
        else:
            panic 'invalid range: left bound bigger than right bound'
};
public function iterate {
    lambda Range Seq[Number]:
    lambda r (from r)
};

// Sequence Operation Functions
public function from {
    lambda Range Seq[Number]:
    native 'Seq from Range'
};
public function next![T] {
    lambda Seq[T] Maybe[(T,Seq[T])]:
    native 'seq-next'
};
public function nil[T] {
    lambda () Seq[T]:
    native 'seq-nil'
};
public function cons[T] {
    lambda (T,Seq[T]) Seq[T]:
    native 'seq-cons'
};
public function map![A,B] {
    lambda (Seq[A], lambda A B) Seq[B]:
    native 'seq-map'
};
public function filter![T] {
    lambda (Seq[T], lambda T Bool) Seq[T]:
    native 'seq-filter'
};
public function scan[T,A] {
    lambda (Seq[T], (A, lambda (A,T) A)) A:
    native 'seq-reduce'
};
public function reduce[T,A] {
    lambda (Seq[T], (A, lambda (A,T) A)) A:
    native 'seq-reduce'
};
public function collect[T] {
    lambda Seq[T] Array[T]:
    native 'seq-collect'
};

// Array Operation Functions
public function get[T] {
    lambda (Array[T],Number) T:
    native 'array-get'
};
public function slice![T] {
    lambda (Array[T],Range) Array[T]:
    native 'array-slice'
};
public function slice-view[T] {
    lambda (Array[T],Range) Array[T]:
    native 'array-slice-view'
};
public function map![A,B] {
    lambda (Array[A], lambda A B) Array[B]:
    native 'array-map'
};
public function map-view[A,B] {
    lambda (Array[A], lambda A B) Array[B]:
    native 'array-map-view'
};
public function iterate[T] {
    lambda Array[T] Seq[T]:
    native 'array-iterate'
};

// String Related Functions
public macro str! (x) := ~String from x;
public function from { lambda Int    String:  native 'String from Int' };
public function from { lambda Number String:  native 'String from Number' };
public function from { lambda Float  String:  native 'String from Float' };
public function from { lambda Int8   String:  native 'String from Int8' };
public function from { lambda Int16  String:  native 'String from Int16' };
public function from { lambda Int32  String:  native 'String from Int32' };
public function from { lambda Int64  String:  native 'String from Int64' };
public function from { lambda Uint8  String:  native 'String from Uint8' };
public function from { lambda Uint16 String:  native 'String from Uint16' };
public function from { lambda Uint32 String:  native 'String from Uint32' };
public function from { lambda Uint64 String:  native 'String from Uint64' };
public function from {
    lambda Complex String:
    lambda (re, im) ("(# + #i)" (str! re, str! im))
};
public function from {
    lambda Range String:
    lambda (l, r) ("[#, #)" (str! l, str! r))
};
public function encode {   /// encodes string into UTF-8 byte sequence
    lambda String Bytes:
    native 'encode-utf8'
};
public function decode {   /// decodes string from UTF-8 byte sequence
    lambda Bytes Maybe[String]:
    native 'decode-utf8'
};
public function substr {
    lambda (String,Range) String:
    lambda (str, range) String(str | slice! range)
};
public function concat {
    lambda Array[String] String:
    native 'str-concat'
};
public function find {
    lambda (String,String) Maybe[Number]:
    native 'str-find'
};
public function contains {
    lambda (String,String) Bool:
    lambda (str, sub)
        switch (str | find sub) {
            case Just _: Yes,
            case N/A:    No
        }
};
public function split {
    lambda (String,String) Seq[String]:
    native 'str-split'
};
public function join {
    lambda (Seq[String], String) String:
    native 'str-join'
};
/*
public function trim {
    lambda (String,Array[Char]) String:
    native 'str-trim'
};
public function trim-left {
    lambda (String,Array[Char]) String:
    native 'str-trim-left'
};
public function trim-right {
    lambda (String,Array[Char]) String:
    native 'str-trim-right'
};
public function has-prefix {
    lambda (String,String) Bool:
    native 'str-has-prefix'
};
public function has-suffix {
    lambda (String,String) Bool:
    native 'str-has-suffix'
};
public function trim-prefix {
    lambda (String,String) String:
    native 'str-trim-prefix'
};
public function trim-suffix {
    lambda (String,String) String:
    native 'str-trim-suffix'
};
*/

// Effect Constructors
public function one-shot[T] {
    lambda T NoExcept[T]:
    native 'one-shot'
};
public function wait {
    lambda { timeout: Number } NoExcept[-]:
    native 'wait'
};
public function tick {
    lambda { interval: Number } NoExcept*[-]:
    native 'tick'
};
public function from {
    lambda Range NoExcept*[Number]:
    native 'NoExcept* from Range'
};
public function from[T] {
    lambda Seq[T] NoExcept*[T]:
    native 'NoExcept* from Seq'
};
public function from[T] {
    lambda Array[T] NoExcept*[T]:
    native 'NoExcept* from Array'
};
public function adapt-no-except[T,E] {
    lambda NoExcept[T] Effect[T,E]:
    native 'adapt-no-except'
};
public function adapt-no-except*[T,E] {
    lambda NoExcept*[T] Effect*[T,E]:
    native 'adapt-no-except'
};

// Effect Operators
public function take-one[T,E] {
    lambda Effect*[T,E] Effect[Maybe[T],E]:
    native 'take-one'
};
public function take-one[T] {
    lambda NoExcept*[T] NoExcept[Maybe[T]]:
    native 'take-one'
};
public function wait-complete[E] {
    lambda Effect*[-,E] Effect[-,E]:
    native 'wait-complete'
};
public function wait-complete {
    lambda NoExcept*[-] NoExcept[-]:
    native 'wait-complete'
};
public function then[A,B,E] {
    lambda (Effect[A,E], (lambda A Effect[B,E])) Effect[B,E]:
    native 'then'
};
public function then[A,B,E] {
    lambda (Effect[A,E], (lambda A NoExcept[B])) Effect[B,E]:
    native 'then'
};
public function then[A,B,E] {
    lambda (NoExcept[A], (lambda A Effect[B,E])) Effect[B,E]:
    native 'then'
};
public function then[A,B] {
    lambda (NoExcept[A], (lambda A NoExcept[B])) NoExcept[B]:
    native 'then'
};
public function then[B,E] {
    lambda (Effect[-,E], Effect[B,E]) Effect[B,E]:
    native 'then-shortcut'
};
public function then[B,E] {
    lambda (Effect[-,E], NoExcept[B]) Effect[B,E]:
    native 'then-shortcut'
};
public function then[B,E] {
    lambda (NoExcept[-], Effect[B,E]) Effect[B,E]:
    native 'then-shortcut'
};
public function then[B] {
    lambda (NoExcept[-], NoExcept[B]) NoExcept[B]:
    native 'then-shortcut'
};
public function catch[T,E,F] {
    lambda (Effect[T,E], (lambda E Effect[T,F])) Effect[T,F]:
    native 'catch'
};
public function catch[T,E] {
    lambda (Effect[T,E], (lambda E NoExcept[T])) NoExcept[T]:
    native 'catch'
};
public function catch-retry[T,E] {
    lambda (Effect[T,E], (lambda E NoExcept[Bool])) Effect[T,E]:
    native 'catch-retry'
};
public function catch-throw[T,E,F] {
    lambda (Effect[T,E], lambda E F) Effect[T,F]:
    native 'catch-throw'
};
public function throw[T,E] {
    lambda E Effect[T,E]:
    native 'throw'
};
public function map![A,B,E] {
    lambda (Effect[A,E], lambda A B) Effect[B,E]:
    native 'map-effect'
};
public function map![A,B] {
    lambda (NoExcept[A], lambda A B) NoExcept[B]:
    native 'map-effect'
};
public function map*[A,B,E] {
    lambda (Effect*[A,E], lambda A B) Effect*[B,E]:
    native 'map-effect'
};
public function map*[A,B] {
    lambda (NoExcept*[A], lambda A B) NoExcept*[B]:
    native 'map-effect'
};
public function filter![T,E] {
    lambda (Effect*[T,E], lambda T Bool) Effect*[T,E]:
    native 'filter-effect'
};
public function filter![T] {
    lambda (NoExcept*[T], lambda T Bool) NoExcept*[T]:
    native 'filter-effect'
};
public function reduce[T,A,E] {
    lambda (Effect*[T,E], (A, lambda (A,T) A)) Effect[A,E]:
    native 'reduce-effect'
};
public function reduce[T,A] {
    lambda (NoExcept*[T], (A, lambda (A,T) A)) NoExcept[A]:
    native 'reduce-effect'
};
public function scan[T,A,E] {
    lambda (Effect*[T,E], (A, lambda (A,T) A)) Effect*[A,E]:
    native 'scan-effect'
};
public function scan[T,A] {
    lambda (NoExcept*[T], (A, lambda (A,T) A)) NoExcept*[A]:
    native 'scan-effect'
};
public function switch-map[A,B,E] {
    lambda (Effect*[A,E], (lambda A Effect*[B,E])) Effect*[B,E]:
    native 'switch-map'
};
public function switch-map[A,B,E] {
    lambda (Effect*[A,E], (lambda A NoExcept*[B])) Effect*[B,E]:
    native 'switch-map'
};
public function switch-map[A,B,E] {
    lambda (NoExcept*[A], (lambda A Effect*[B,E])) Effect*[B,E]:
    native 'switch-map'
};
public function switch-map[A,B] {
    lambda (NoExcept*[A], (lambda A NoExcept*[B])) NoExcept*[B]:
    native 'switch-map'
};
public function merge-map[A,B,E] {
    lambda (Effect*[A,E], (lambda A Effect*[B,E])) Effect*[B,E]:
    native 'merge-map'
};
public function merge-map[A,B,E] {
    lambda (Effect*[A,E], (lambda A NoExcept*[B])) Effect*[B,E]:
    native 'merge-map'
};
public function merge-map[A,B,E] {
    lambda (NoExcept*[A], (lambda A Effect*[B,E])) Effect*[B,E]:
    native 'merge-map'
};
public function merge-map[A,B] {
    lambda (NoExcept*[A], (lambda A NoExcept*[B])) NoExcept*[B]:
    native 'merge-map'
};
public function concat-map[A,B,E] {
    lambda (Effect*[A,E], (lambda A Effect*[B,E])) Effect*[B,E]:
    native 'concat-map'
};
public function concat-map[A,B,E] {
    lambda (Effect*[A,E], (lambda A NoExcept*[B])) Effect*[B,E]:
    native 'concat-map'
};
public function concat-map[A,B,E] {
    lambda (NoExcept*[A], (lambda A Effect*[B,E])) Effect*[B,E]:
    native 'concat-map'
};
public function concat-map[A,B] {
    lambda (NoExcept*[A], (lambda A NoExcept*[B])) NoExcept*[B]:
    native 'concat-map'
};
public function mix-map[A,B,E] {
    lambda (Effect*[A,E], (Number, lambda A Effect*[B,E])) Effect*[B,E]:
    native 'mix-map'
};
public function mix-map[A,B,E] {
    lambda (Effect*[A,E], (Number, lambda A NoExcept*[B])) Effect*[B,E]:
    native 'mix-map'
};
public function mix-map[A,B,E] {
    lambda (NoExcept*[A], (Number, lambda A Effect*[B,E])) Effect*[B,E]:
    native 'mix-map'
};
public function mix-map[A,B] {
    lambda (NoExcept*[A], (Number, lambda A NoExcept*[B])) NoExcept*[B]:
    native 'mix-map'
};
