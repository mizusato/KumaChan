module Core;

// Basic Types
type Bool   native 'Bool';
type Byte   native 'Byte';
type Word   native 'Word';
type Dword  native 'Dword';
type Qword  native 'Qword';

// Number Types
type Int       native 'Int';
type Float     native 'Float';

// Collection Types
type Bytes     native 'Bytes';
type Map(K,V)  native 'Map';
type Stack(T)  native 'Stack';
type Heap(T)   native 'Heap';
type List(T)   native 'List';

// Effect Type
type Effect(T,E)  native 'Effect';

// Basic Sum Types
type Maybe(T) union {
    type Just [T];
    type Nothing [];
};
type Result(T,E) union {
    type OK [T];
    type Error [E];
};

// Arithmetic Functions
// Integer
global + := (&Int. &Int.Int)  native 'int-plus';
global - := (&Int. &Int.Int)  native 'int-minus';
global minus := (&Int.Int)    native 'int-minus-unary';
global * := (&Int. &Int.Int)  native 'int-times';
global / := (&Int. &Int.Int)  native 'int-divide';
global % := (&Int. &Int.Int)  native 'int-modulo';
global divmod := (&Int. &Int.(Int,Int))  native 'int-divmod';
// Floating Point Number
global + := (&Float. &Float.Float)  native 'float-plus';
global - := (&Float. &Float.Float)  native 'float-minus';
global minus := (&Float.Float)      native 'float-minus-unary';
global * := (&Float. &Float.Float)  native 'float-times';
global / := (&Float. &Float.Float)  native 'float-divide';
global % := (&Float. &Float.Float)  native 'float-modulo';
global divmod := (&Float. &Float.(Float,Float))  native 'float-divmod';
