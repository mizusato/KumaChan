module Core;

// Basic Types
type Bit    native;
type Byte   native;
type Word   native;
type Dword  native;
type Qword  native;
type Int    native;

// Container Types
type Bytes     native;
type String    native;
type Seq[T]    native;
type Array[T]  native;
type Heap[T]   native;
type Set[T]    native;
type Map[K,V]  native;

// Effect Type
type Effect[T,E]  native;

// Basic Derived Types
type Int64   (Qword);
type Uint64  (Qword);
type Int32   (Dword);
type Uint32  (Dword);
type Int16   (Word);
type Uint16  (Word);
type Int8    (Byte);
type Uint8   (Byte);
type Char    (Dword);
type Float64  native;
type Float    opaque (Float64);

// Basic Sum Types
type Bool union {
    type Yes ();
    type No  ();
};
type Maybe[T] union {
    type Just(T);
    type Nothing();
};
type Result[T,E] union {
    type OK(T);
    type NG(E);
};

// Singly-Linked List
type List[T] union {
    type Nil  ();
    type Cons (T, List[T]);
};

public function
map[A,B] {
    `(Maybe[A], `A => B) => Maybe[B]:
    `(maybe-a, f) => match(maybe-a) {
        case Just a:  Just f(a),
        case Nothing: Nothing
    }
};

public function
map[A,B] {
    `(List[A], `A => B) => List[B]:
    `(list, f) => match(list) {
        case Cons(x, xs): Cons(f(x), map(xs, f)),
        case Nil: Nil
    }
};

public function
filter[T] {
    `(List[T], `T => Bool) => List[T]:
    `(list, f) => match(list) {
        case Cons(x, xs): let {
            rest := filter(xs, f),
            return if { f(x): Cons(x, rest), else: rest }
        },
        case Nil: Nil
    }
};

public function
reduce[T,A] {
    `(List[T], A, `(A, T) => A) => A:
    `(list, acc, f) => match(list) {
        case Cons(x, xs): reduce(xs, f(acc, x), f),
        case Nil: Nil
    }
};
