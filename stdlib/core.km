module Core;


/**
 *  IMPORTANT: The following type definitions should be kept consistent
 *             with the `stdlib.go` file.
 */

// Basic Types
type Bit    native;  // bool
type Byte   native;  // uint8, int8
type Word   native;  // uint16, int16
type Dword  native;  // uint32, int32
type Qword  native;  // uint64, int64, float64
type Int    native;  // *big.Int

// Container Types
type Seq[T]    native;  // container.Seq
type Array[T]  native;  // []T, container.Array
type Heap[T]   native;  // container.Heap
type Set[T]    native;  // container.Set
type Map[K,V]  native;  // container.Map

// Effect Type
type Effect*[T,E]  native;  // rx.Effect
type Effect[T,E]   protected Effect*[T,E];

// Fixed Int Types
type Int64   protected Qword;
type Uint64  protected Qword;
type Int32   protected Dword;
type Uint32  protected Dword;
type Int16   protected Word;
type Uint16  protected Word;
type Int8    protected Byte;
type Uint8   protected Byte;

// Basic Boxed Types
type Float64  protected Qword;
type Float    protected Float64;  // float64 with NaN and Infinity excluded
type Complex  (Float, Float);
type Char     Uint32;  // rune
type String   protected Array[Char];  // []rune
type Bytes    protected Array[Byte];  // []byte

// Basic Sum Types
type Bool union {
    type Yes;
    type No;
};
type Maybe[T] union {
    type Just[T] T;
    type N/A;
};
type Result[T,E] union {
    type OK[T] T;
    type NG[E] E;
};
type Ordering union {
    type <<;
    type ==;
    type >>;
};

// Debugging Types
type Debug[T]  protected T;
type Never[T]  protected T;

// Debugging Functions (With Side Effects)
public function trace[T] {
    lambda T Debug[T]:
    native 'trace'
};
public function panic[T] {
    lambda String Never[T]:
    native 'panic'
};

// Logic Macros
public macro not(p)    := ~Bool(if p { No } else { Yes });
public macro and(p, q) := ~Bool(if p { if q { Yes } else { No } } else { No });
public macro  or(p, q) := ~Bool(if p { Yes } else { if q { Yes } else { No } });

// Baisc Arithmetic Functions
public function + { lambda (Int,Int) Int:  native '+Int' };
public function - { lambda (Int,Int) Int:  native '-Int' };
public function * { lambda (Int,Int) Int:  native '*Int' };
// TODO: ** (integer power)
public function quorem { lambda (Int,Int) (Int,Int):  native 'quorem' };
public function divmod { lambda (Int,Int) (Int,Int):  native 'divmod' };
public function - {
    lambda Int   Int:
    lambda  n  $(0 - n)
};
public function / {
    lambda (Int,Int) Int:
    lambda (a, b)
        let {
            (q, _) := quorem(a, b),
            return q
        }
};
public function % {
    lambda (Int,Int) Int:
    lambda (a, b)
        let {
            (_, r) := quorem(a, b),
            return r
        }
};
public function div {
    lambda (Int,Int) Int:
    lambda (a, b)
        let {
            (q, _) := divmod(a, b),
            return q
        }
};
public function mod {
    lambda (Int,Int) Int:
    lambda (a, b)
        let {
            (_, r) := divmod(a, b),
            return r
        }
};
public function + { lambda (Float, Float) Float:  native '+Float' };
public function - { lambda (Float, Float) Float:  native '-Float' };
public function * { lambda (Float, Float) Float:  native '*Float' };
public function / { lambda (Float, Float) Float:  native '/Float' };
public function % { lambda (Float, Float) Float:  native '%Float' };
public function - {
    lambda Float   Float:
    lambda   x   $(0.0 - x)
};
public function + { lambda (Int8, Int8) Int8:  native '+Int8' };
public function - { lambda (Int8, Int8) Int8:  native '-Int8' };
public function * { lambda (Int8, Int8) Int8:  native '*Int8' };
public function / { lambda (Int8, Int8) Int8:  native '/Int8' };
public function % { lambda (Int8, Int8) Int8:  native '%Int8' };
public function - {
    lambda Int8   Int8:
    lambda  n   $(0 - n)
};
public function + { lambda (Uint8, Uint8) Uint8:  native '+Uint8' };
public function - { lambda (Uint8, Uint8) Uint8:  native '-Uint8' };
public function * { lambda (Uint8, Uint8) Uint8:  native '*Uint8' };
public function / { lambda (Uint8, Uint8) Uint8:  native '/Uint8' };
public function % { lambda (Uint8, Uint8) Uint8:  native '%Uint8' };
public function - {
    lambda Uint8  Uint8:
    lambda   n   $(0 - n)
};
public function + { lambda (Int16, Int16) Int16:  native '+Int16' };
public function - { lambda (Int16, Int16) Int16:  native '-Int16' };
public function * { lambda (Int16, Int16) Int16:  native '*Int16' };
public function / { lambda (Int16, Int16) Int16:  native '/Int16' };
public function % { lambda (Int16, Int16) Int16:  native '%Int16' };
public function - {
    lambda Int16  Int16:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint16, Uint16) Uint16:  native '+Uint16' };
public function - { lambda (Uint16, Uint16) Uint16:  native '-Uint16' };
public function * { lambda (Uint16, Uint16) Uint16:  native '*Uint16' };
public function / { lambda (Uint16, Uint16) Uint16:  native '/Uint16' };
public function % { lambda (Uint16, Uint16) Uint16:  native '%Uint16' };
public function - {
    lambda Uint16  Uint16:
    lambda   n    $(0 - n)
};
public function + { lambda (Int32, Int32) Int32:  native '+Int32' };
public function - { lambda (Int32, Int32) Int32:  native '-Int32' };
public function * { lambda (Int32, Int32) Int32:  native '*Int32' };
public function / { lambda (Int32, Int32) Int32:  native '/Int32' };
public function % { lambda (Int32, Int32) Int32:  native '%Int32' };
public function - {
    lambda Int32  Int32:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint32, Uint32) Uint32:  native '+Uint32' };
public function - { lambda (Uint32, Uint32) Uint32:  native '-Uint32' };
public function * { lambda (Uint32, Uint32) Uint32:  native '*Uint32' };
public function / { lambda (Uint32, Uint32) Uint32:  native '/Uint32' };
public function % { lambda (Uint32, Uint32) Uint32:  native '%Uint32' };
public function - {
    lambda Uint32  Uint32:
    lambda   n    $(0 - n)
};
public function + { lambda (Int64, Int64) Int64:  native '+Int64' };
public function - { lambda (Int64, Int64) Int64:  native '-Int64' };
public function * { lambda (Int64, Int64) Int64:  native '*Int64' };
public function / { lambda (Int64, Int64) Int64:  native '/Int64' };
public function % { lambda (Int64, Int64) Int64:  native '%Int64' };
public function - {
    lambda Int64  Int64:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint64, Uint64) Uint64:  native '+Uint64' };
public function - { lambda (Uint64, Uint64) Uint64:  native '-Uint64' };
public function * { lambda (Uint64, Uint64) Uint64:  native '*Uint64' };
public function / { lambda (Uint64, Uint64) Uint64:  native '/Uint64' };
public function % { lambda (Uint64, Uint64) Uint64:  native '%Uint64' };
public function - {
    lambda Uint64  Uint64:
    lambda   n    $(0 - n)
};

// Advanced Arithmetic Functions
public function floor! { lambda Float Float:  native 'floor' };
public function  ceil! { lambda Float Float:  native 'ceil' };
public function round! { lambda Float Float:  native 'round' };
public function ** { lambda (Float,Float) Float:  native 'real-**' };
public function sqrt { lambda Float Float:  native 'real-sqrt' };
public function cbrt { lambda Float Float:  native 'real-cbrt' };
public function exp! { lambda Float Float:  native 'real-exp' };
public function log! { lambda Float Float:  native 'real-log' };
public function  sin { lambda Float Float: native 'real-sin' };
public function  cos { lambda Float Float: native 'real-cos' };
public function  tan { lambda Float Float: native 'real-tan' };
public function asin { lambda Float Float: native 'real-asin' };
public function acos { lambda Float Float: native 'real-acos' };
public function atan { lambda Float Float: native 'real-atan' };
public function atan2 { lambda { y: Float, x: Float } Float:  native 'atan2' };
public function log! {
    lambda { base: Float, x: Float } Float:
    lambda {base,x} $((log! x) / (log! base))
};
public function log2! {
    lambda Float Float:
    lambda x (log! { base: 2.0, x })
};
public function log10! {
    lambda Float Float:
    lambda x (log! { base: 10.0, x })
};

// Comparison Functions & Macros
public macro != (a, b) := not $(a = b);
public macro  > (a, b) := $(b < a);
public macro <= (a, b) := not $(a > b);
public macro >= (a, b) := not $(a < b);
public function  = { lambda (String,String) Bool:      native '=String' };
public function  < { lambda (String,String) Bool:      native '<String' };
public function <> { lambda (String,String) Ordering:  native '<>String' };
public function  = { lambda (Int,Int) Bool:      native '=Int' };
public function  < { lambda (Int,Int) Bool:      native '<Int' };
public function <> { lambda (Int,Int) Ordering:  native '<>Int' };
public function  = { lambda (Float,Float) Bool:      native '=Float' };
public function  < { lambda (Float,Float) Bool:      native '<Float' };
public function <> { lambda (Float,Float) Ordering:  native '<>Float' };
public function  = { lambda (Int8,Int8) Bool:      native '=Int8' };
public function  < { lambda (Int8,Int8) Bool:      native '<Int8' };
public function <> { lambda (Int8,Int8) Ordering:  native '<>Int8' };
public function  = { lambda (Uint8,Uint8) Bool:      native '=Uint8' };
public function  < { lambda (Uint8,Uint8) Bool:      native '<Uint8' };
public function <> { lambda (Uint8,Uint8) Ordering:  native '<>Uint8' };
public function  = { lambda (Int16,Int16) Bool:      native '=Int16' };
public function  < { lambda (Int16,Int16) Bool:      native '<Int16' };
public function <> { lambda (Int16,Int16) Ordering:  native '<>Int16' };
public function  = { lambda (Uint16,Uint16) Bool:      native '=Uint16' };
public function  < { lambda (Uint16,Uint16) Bool:      native '<Uint16' };
public function <> { lambda (Uint16,Uint16) Ordering:  native '<>Uint16' };
public function  = { lambda (Int32,Int32) Bool:      native '=Int32' };
public function  < { lambda (Int32,Int32) Bool:      native '<Int32' };
public function <> { lambda (Int32,Int32) Ordering:  native '<>Int32' };
public function  = { lambda (Uint32,Uint32) Bool:      native '=Uint32' };
public function  < { lambda (Uint32,Uint32) Bool:      native '<Uint32' };
public function <> { lambda (Uint32,Uint32) Ordering:  native '<>Uint32' };
public function  = { lambda (Int64,Int64) Bool:      native '=Int64' };
public function  < { lambda (Int64,Int64) Bool:      native '<Int64' };
public function <> { lambda (Int64,Int64) Ordering:  native '<>Int64' };
public function  = { lambda (Uint64,Uint64) Bool:      native '=Uint64' };
public function  < { lambda (Uint64,Uint64) Bool:      native '<Uint64' };
public function <> { lambda (Uint64,Uint64) Ordering:  native '<>Uint64' };

// Bitwise Operation Functions
public function AND { lambda (Bit,Bit) Bit:  native '&Bit' };
public function  OR { lambda (Bit,Bit) Bit:  native '|Bit' };
public function NOT { lambda Bit Bit:        native '~Bit' };
public function AND { lambda (Byte,Byte) Byte:  native '&Byte' };
public function  OR { lambda (Byte,Byte) Byte:  native '|Byte' };
public function NOT { lambda Byte Byte:         native '~Byte' };
public function XOR { lambda (Byte,Byte) Byte:  native '^Byte' };
public function SHL { lambda (Byte,Byte) Byte:  native '<<Byte' };
public function SHR { lambda (Byte,Byte) Byte:  native '>>Byte' };
public function AND { lambda (Word,Word) Word:  native '&Word' };
public function  OR { lambda (Word,Word) Word:  native '|Word' };
public function NOT { lambda Word Word:         native '~Word' };
public function XOR { lambda (Word,Word) Word:  native '^Word' };
public function SHL { lambda (Word,Byte) Word:  native '<<Word' };
public function SHR { lambda (Word,Byte) Word:  native '>>Word' };
public function AND { lambda (Dword,Dword) Dword:  native '&Dword' };
public function  OR { lambda (Dword,Dword) Dword:  native '|Dword' };
public function NOT { lambda Dword Dword:          native '~Dword' };
public function XOR { lambda (Dword,Dword) Dword:  native '^Dword' };
public function SHL { lambda (Dword,Byte) Dword:   native '<<Dword' };
public function SHR { lambda (Dword,Byte) Dword:   native '>>Dword' };
public function AND { lambda (Qword,Qword) Qword:  native '&Qword' };
public function  OR { lambda (Qword,Qword) Qword:  native '|Qword' };
public function NOT { lambda Qword Qword:          native '~Qword' };
public function XOR { lambda (Qword,Qword) Qword:  native '^Qword' };
public function SHL { lambda (Qword,Byte) Qword:   native '<<Qword' };
public function SHR { lambda (Qword,Byte) Qword:   native '>>Qword' };

// String Related Functions
public macro str! (x) := ~String from x;
public function from { lambda Int    String:  native 'String from Int' };
public function from { lambda Float  String:  native 'String from Float' };
public function from { lambda Int8   String:  native 'String from Int8' };
public function from { lambda Int16  String:  native 'String from Int16' };
public function from { lambda Int32  String:  native 'String from Int32' };
public function from { lambda Int64  String:  native 'String from Int64' };
public function from { lambda Uint8  String:  native 'String from Uint8' };
public function from { lambda Uint16 String:  native 'String from Uint16' };
public function from { lambda Uint32 String:  native 'String from Uint32' };
public function from { lambda Uint64 String:  native 'String from Uint64' };

// Effect Operators
public function then[T,E] {
    lambda(Effect[(),()], Effect[T,E]) Effect[T,E]:
    native 'effect-then-preset'
};
public function catch[T,E] {
    lambda(Effect[T,E], lambda E Effect[(),()]) Effect[T,()]:
    native 'effect-catch'
};
/*
public function map![A,B,E] {
    lambda(Effect*[A,E], lambda A B) Effect*[B,E]:
    native 'effect-map'
};
public function then[A,B,E] {
    lambda(Effect[A,()], lambda A Effect[B,E]) Effect[B,E]:
    native 'effect-then'
};
public function then*[A,B,E] {
    lambda(Effect[A,()], lambda A Effect*[B,E]) Effect*[B,E]:
    native 'effect-then*'
};
public function then*[T,E] {
    lambda(Effect[(),()], Effect*[T,E]) Effect*[T,E]:
    native 'effect-then*-preset'
};
public function next![A,B,E] {
    lambda(Effect[A,E], lambda A Effect[B,E]) Effect[B,E]:
    native 'effect-next'
};
public function next*[A,B,E] {
    lambda(Effect[A,E], lambda A Effect*[B,E]) Effect*[B,E]:
    native 'effect-next*'
};
public function map-error[T,E,F] {
    lambda(Effect[T,E], lambda E F) Effect[T,F]:
    native 'effect-map-error'
};
public function map-error[T,E,F] {
    lambda(Effect*[T,E], lambda E F) Effect*[T,F]:
    native 'effect-map-error-*'
};
*/
