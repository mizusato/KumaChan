module Core;


/**
 *  IMPORTANT: The following type definitions should be kept consistent
 *             with the `stdlib.go` file.
 */

// Basic Types
type Bit    native;  // bool
type Byte   native;  // uint8, int8
type Word   native;  // uint16, int16
type Dword  native;  // uint32, int32
type Qword  native;  // uint64, int64, float64
type Int    native;  // *big.Int

// Container Types
type Seq[T]    native;  // container.Seq
type Array[T]  native;  // []T, container.Array
type Heap[T]   native;  // container.Heap
type Set[T]    native;  // container.Set
type Map[K,V]  native;  // container.Map

// Effect Type
type Effect*[T,E]  native;  // rx.Effect
type Effect[T,E]   protected Effect*[T,E];

// Fixed Int Types
type Int64   protected Qword;
type Uint64  protected Qword;
type Int32   protected Dword;
type Uint32  protected Dword;
type Int16   protected Word;
type Uint16  protected Word;
type Int8    protected Byte;
type Uint8   protected Byte;

// Basic Boxed Types
type Float64  protected Qword;
type Float    protected Float64;  // float64 with NaN and Infinity excluded
type Complex  (Float, Float);
type Char     Uint32;  // rune
type String   protected Array[Char];  // []rune
type Bytes    protected Array[Byte];  // []byte

// Basic Sum Types
type Bool union {
    type Yes;
    type No;
};
type Maybe[T] union {
    type Just[T] T;
    type N/A;
};
type Result[T,E] union {
    type OK[T] T;
    type NG[E] E;
};
type Ordering union {
    type <<;
    type ==;
    type >>;
};

// Debugging Types
type Debug[T]  protected T;
type Never[T]  protected T;

// Debugging Functions (With Side Effects)
public function trace[T] {
    lambda T Debug[T]:
    native 'trace'
};
public function panic[T] {
    lambda String Never[T]:
    native 'panic'
};

// Logic Macros
public macro not(p)    := ~Bool(if p: No, else: Yes);
public macro and(p, q) := ~Bool(if p: (if q: Yes, else: No), else: No);
public macro  or(p, q) := ~Bool(if p: Yes, else: (if q: Yes, else: No));

// Baisc Arithmetic Functions
public function + { lambda (Int,Int) Int:  native '+Int' };
public function - { lambda (Int,Int) Int:  native '-Int' };
public function * { lambda (Int,Int) Int:  native '*Int' };
public function quorem { lambda (Int,Int) (Int,Int):  native 'quorem' };
public function divmod { lambda (Int,Int) (Int,Int):  native 'divmod' };
public function - {
    lambda Int   Int:
    lambda  n  $(0 - n)
};
public function / {
    lambda (Int,Int) Int:
    lambda (a, b)    let (q, _) := quorem(a, b), return q
};
public function % {
    lambda (Int,Int) Int:
    lambda (a, b)    let (_, r) := quorem(a, b), return r
};
public function div {
    lambda (Int,Int) Int:
    lambda (a, b)    let (q, _) := divmod(a, b), return q
};
public function mod {
    lambda (Int,Int) Int:
    lambda (a, b)    let (_, r) := divmod(a, b), return r
};
public function ** {
    lambda (Int,Int) Int:
    lambda (n, p)
        let rec: pow := [lambda (Int,Int,Int) Int]
                        power-by-squaring (pow, panic[Int]),
        return pow (1, n, p)
};
private macro power-by-squaring (recursive-call, panic)
:= lambda(t, n, p)
    switch $(p <> 0) {
    case <<:
        panic 'taking negative power of a Int value is not supported',
    case ==:
        if $(n = 0):
            panic 'cannot evaluate 0 to the power of 0',
        else:
            t,
    case >>:
        if $(p = 1):
            $(t * n),
        else:
            let (q, r) := $(p divmod 2),
                square := $(n * n),
            return
                if $(r = 1):
                    recursive-call ($(t * n), square, q),
                else:
                    recursive-call (t, square, q)
    };
public function + { lambda (Float, Float) Float:  native '+Float' };
public function - { lambda (Float, Float) Float:  native '-Float' };
public function * { lambda (Float, Float) Float:  native '*Float' };
public function / { lambda (Float, Float) Float:  native '/Float' };
public function % { lambda (Float, Float) Float:  native '%Float' };
public function - {
    lambda Float   Float:
    lambda   x   $(0.0 - x)
};
public function + { lambda (Int8, Int8) Int8:  native '+Int8' };
public function - { lambda (Int8, Int8) Int8:  native '-Int8' };
public function * { lambda (Int8, Int8) Int8:  native '*Int8' };
public function / { lambda (Int8, Int8) Int8:  native '/Int8' };
public function % { lambda (Int8, Int8) Int8:  native '%Int8' };
public function - {
    lambda Int8   Int8:
    lambda  n   $(0 - n)
};
public function + { lambda (Uint8, Uint8) Uint8:  native '+Uint8' };
public function - { lambda (Uint8, Uint8) Uint8:  native '-Uint8' };
public function * { lambda (Uint8, Uint8) Uint8:  native '*Uint8' };
public function / { lambda (Uint8, Uint8) Uint8:  native '/Uint8' };
public function % { lambda (Uint8, Uint8) Uint8:  native '%Uint8' };
public function - {
    lambda Uint8  Uint8:
    lambda   n   $(0 - n)
};
public function + { lambda (Int16, Int16) Int16:  native '+Int16' };
public function - { lambda (Int16, Int16) Int16:  native '-Int16' };
public function * { lambda (Int16, Int16) Int16:  native '*Int16' };
public function / { lambda (Int16, Int16) Int16:  native '/Int16' };
public function % { lambda (Int16, Int16) Int16:  native '%Int16' };
public function - {
    lambda Int16  Int16:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint16, Uint16) Uint16:  native '+Uint16' };
public function - { lambda (Uint16, Uint16) Uint16:  native '-Uint16' };
public function * { lambda (Uint16, Uint16) Uint16:  native '*Uint16' };
public function / { lambda (Uint16, Uint16) Uint16:  native '/Uint16' };
public function % { lambda (Uint16, Uint16) Uint16:  native '%Uint16' };
public function - {
    lambda Uint16  Uint16:
    lambda   n    $(0 - n)
};
public function + { lambda (Int32, Int32) Int32:  native '+Int32' };
public function - { lambda (Int32, Int32) Int32:  native '-Int32' };
public function * { lambda (Int32, Int32) Int32:  native '*Int32' };
public function / { lambda (Int32, Int32) Int32:  native '/Int32' };
public function % { lambda (Int32, Int32) Int32:  native '%Int32' };
public function - {
    lambda Int32  Int32:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint32, Uint32) Uint32:  native '+Uint32' };
public function - { lambda (Uint32, Uint32) Uint32:  native '-Uint32' };
public function * { lambda (Uint32, Uint32) Uint32:  native '*Uint32' };
public function / { lambda (Uint32, Uint32) Uint32:  native '/Uint32' };
public function % { lambda (Uint32, Uint32) Uint32:  native '%Uint32' };
public function - {
    lambda Uint32  Uint32:
    lambda   n    $(0 - n)
};
public function + { lambda (Int64, Int64) Int64:  native '+Int64' };
public function - { lambda (Int64, Int64) Int64:  native '-Int64' };
public function * { lambda (Int64, Int64) Int64:  native '*Int64' };
public function / { lambda (Int64, Int64) Int64:  native '/Int64' };
public function % { lambda (Int64, Int64) Int64:  native '%Int64' };
public function - {
    lambda Int64  Int64:
    lambda   n   $(0 - n)
};
public function + { lambda (Uint64, Uint64) Uint64:  native '+Uint64' };
public function - { lambda (Uint64, Uint64) Uint64:  native '-Uint64' };
public function * { lambda (Uint64, Uint64) Uint64:  native '*Uint64' };
public function / { lambda (Uint64, Uint64) Uint64:  native '/Uint64' };
public function % { lambda (Uint64, Uint64) Uint64:  native '%Uint64' };
public function - {
    lambda Uint64  Uint64:
    lambda   n    $(0 - n)
};

// Advanced Arithmetic Functions
public function floor! { lambda Float Float:  native 'floor' };
public function  ceil! { lambda Float Float:  native 'ceil' };
public function round! { lambda Float Float:  native 'round' };
public function ** { lambda (Float,Float) Float:  native 'real-**' };
public function sqrt { lambda Float Float:  native 'real-sqrt' };
public function cbrt { lambda Float Float:  native 'real-cbrt' };
public function exp! { lambda Float Float:  native 'real-exp' };
public function log! { lambda Float Float:  native 'real-log' };
public function  sin { lambda Float Float: native 'real-sin' };
public function  cos { lambda Float Float: native 'real-cos' };
public function  tan { lambda Float Float: native 'real-tan' };
public function asin { lambda Float Float: native 'real-asin' };
public function acos { lambda Float Float: native 'real-acos' };
public function atan { lambda Float Float: native 'real-atan' };
public function atan2 { lambda { y: Float, x: Float } Float:  native 'atan2' };
public function log! {
    lambda { base: Float, x: Float } Float:
    lambda {base,x} $((log! x) / (log! base))
};
public function log2! {
    lambda Float Float:
    lambda x (log! { base: 2.0, x })
};
public function log10! {
    lambda Float Float:
    lambda x (log! { base: 10.0, x })
};
private macro re-im-> (z, expr) := (let (re, im) := z, return expr);
public function re! {
    lambda Complex Float:
    lambda (re, _) re
};
public function im! {
    lambda Complex Float:
    lambda (_, im) im
};
public function conj! {
    lambda Complex Complex:
    lambda (re, im) (Complex (re, (- im)))
};
public function arg! {
    lambda Complex Float:
    lambda (re, im) (atan2 { y: im, x: re })
};
public function norm! {
    lambda Complex Float:
    lambda (re, im) (sqrt $($(re * re) + $(im * im)))
};
public function polar! {
    lambda { norm: Float, arg: Float } Complex:
    lambda { norm, arg }
        if $(norm >= 0.0):
            Complex ( $(norm * (cos arg)), $(norm * (sin arg)) ),
        else:
            panic[Complex] 'invalid input: negative norm'
};
public function polar! {
    lambda Float Complex:
    lambda  arg  polar! { norm: 1.0, arg }
};
public function + {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (r1, i1) := z1,
            (r2, i2) := z2,
        return Complex ($(r1 + r2), $(i1 + i2))
};
public function + {
    lambda (Float,Complex) Complex:
    lambda (x, z) (z | re-im-> Complex ($(x + re), im))
};
public function + {
    lambda (Complex,Float) Complex:
    lambda (z, x) $(x + z)
};
public function - {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (r1, i1) := z1,
            (r2, i2) := z2,
        return Complex ($(r1 - r2), $(i1 - i2))
};
public function - {
    lambda (Float,Complex) Complex:
    lambda (x, z) $(x + (- z))
};
public function - {
    lambda (Complex,Float) Complex:
    lambda (z, x) $(z + (- x))
};
public function * {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (a, b) := z1,
            (c, d) := z2,
        return Complex ( $($(a * c) - $(b * d)), $($(a * d) + $(b * c)) )
};
public function * {
    lambda (Float,Complex) Complex:
    lambda (x, z) (z | re-im-> Complex ($(x * re), $(x * im)))
};
public function * {
    lambda (Complex,Float) Complex:
    lambda (z, x) $(x * z)
};
public function / {
    lambda (Complex,Complex) Complex:
    lambda (z1, z2)
        let (a, b) := z1,
            (c, d) := z2,
               u   := Complex ( $($(a * c) + $(b * d)), $($(b * c) - $(a * d)) ),
               v   := Complex ( $(1.0 / $($(c * c) + $(d * d))), 0.0 ),
        return $(u * v)
};
public function / {
    lambda (Float,Complex) Complex:
    lambda (x, z) $((Complex (x, 0.0)) / z)
};
public function / {
    lambda (Complex,Float) Complex:
    lambda (z, x) (z | re-im-> Complex ($(re / x), $(im / x)))
};
public function - {
    lambda Complex Complex:
    lambda (re, im) (Complex ((- re), (- im)))
};
public function exp! {
    lambda Complex Complex:
    lambda (re, im) (polar! { norm: exp!(re), arg: im })
};
public function log! {
    lambda Complex Complex:
    lambda    z    Complex((log! norm! z), (arg! z))
};
public function sin {
    lambda Complex Complex:
    lambda    z    $( $((exp! $(i * z)) - (exp! $((- i) * z))) / $(2.0 * i) )
};
public function cos {
    lambda Complex Complex:
    lambda    z    $( $((exp! $(i * z)) + (exp! $((- i) * z))) / $(2.0 * _1) )
};
public function tan {
    lambda Complex Complex:
    lambda    z    $((sin z) / (cos z))
};

// Arithmetic Constants
public const pi := [Float] acos -1.0;
public const  e := [Float] exp! 1.0;
public const  i := [Complex] Complex (0.0, 1.0);
public const _1 := [Complex] Complex (1.0, 0.0);

// Comparison Functions & Macros
public macro != (a, b) := not $(a = b);
public macro  > (a, b) := $(b < a);
public macro <= (a, b) := not $(a > b);
public macro >= (a, b) := not $(a < b);
public function  = { lambda (String,String) Bool:      native '=String' };
public function  < { lambda (String,String) Bool:      native '<String' };
public function <> { lambda (String,String) Ordering:  native '<>String' };
public function  = { lambda (Int,Int) Bool:      native '=Int' };
public function  < { lambda (Int,Int) Bool:      native '<Int' };
public function <> { lambda (Int,Int) Ordering:  native '<>Int' };
public function  = { lambda (Float,Float) Bool:      native '=Float' };
public function  < { lambda (Float,Float) Bool:      native '<Float' };
public function <> { lambda (Float,Float) Ordering:  native '<>Float' };
public function  = { lambda (Int8,Int8) Bool:      native '=Int8' };
public function  < { lambda (Int8,Int8) Bool:      native '<Int8' };
public function <> { lambda (Int8,Int8) Ordering:  native '<>Int8' };
public function  = { lambda (Uint8,Uint8) Bool:      native '=Uint8' };
public function  < { lambda (Uint8,Uint8) Bool:      native '<Uint8' };
public function <> { lambda (Uint8,Uint8) Ordering:  native '<>Uint8' };
public function  = { lambda (Int16,Int16) Bool:      native '=Int16' };
public function  < { lambda (Int16,Int16) Bool:      native '<Int16' };
public function <> { lambda (Int16,Int16) Ordering:  native '<>Int16' };
public function  = { lambda (Uint16,Uint16) Bool:      native '=Uint16' };
public function  < { lambda (Uint16,Uint16) Bool:      native '<Uint16' };
public function <> { lambda (Uint16,Uint16) Ordering:  native '<>Uint16' };
public function  = { lambda (Int32,Int32) Bool:      native '=Int32' };
public function  < { lambda (Int32,Int32) Bool:      native '<Int32' };
public function <> { lambda (Int32,Int32) Ordering:  native '<>Int32' };
public function  = { lambda (Uint32,Uint32) Bool:      native '=Uint32' };
public function  < { lambda (Uint32,Uint32) Bool:      native '<Uint32' };
public function <> { lambda (Uint32,Uint32) Ordering:  native '<>Uint32' };
public function  = { lambda (Int64,Int64) Bool:      native '=Int64' };
public function  < { lambda (Int64,Int64) Bool:      native '<Int64' };
public function <> { lambda (Int64,Int64) Ordering:  native '<>Int64' };
public function  = { lambda (Uint64,Uint64) Bool:      native '=Uint64' };
public function  < { lambda (Uint64,Uint64) Bool:      native '<Uint64' };
public function <> { lambda (Uint64,Uint64) Ordering:  native '<>Uint64' };

// Bitwise Operation Functions
public function AND { lambda (Bit,Bit) Bit:  native '&Bit' };
public function  OR { lambda (Bit,Bit) Bit:  native '|Bit' };
public function NOT { lambda Bit Bit:        native '~Bit' };
public function AND { lambda (Byte,Byte) Byte:  native '&Byte' };
public function  OR { lambda (Byte,Byte) Byte:  native '|Byte' };
public function NOT { lambda Byte Byte:         native '~Byte' };
public function XOR { lambda (Byte,Byte) Byte:  native '^Byte' };
public function SHL { lambda (Byte,Byte) Byte:  native '<<Byte' };
public function SHR { lambda (Byte,Byte) Byte:  native '>>Byte' };
public function AND { lambda (Word,Word) Word:  native '&Word' };
public function  OR { lambda (Word,Word) Word:  native '|Word' };
public function NOT { lambda Word Word:         native '~Word' };
public function XOR { lambda (Word,Word) Word:  native '^Word' };
public function SHL { lambda (Word,Byte) Word:  native '<<Word' };
public function SHR { lambda (Word,Byte) Word:  native '>>Word' };
public function AND { lambda (Dword,Dword) Dword:  native '&Dword' };
public function  OR { lambda (Dword,Dword) Dword:  native '|Dword' };
public function NOT { lambda Dword Dword:          native '~Dword' };
public function XOR { lambda (Dword,Dword) Dword:  native '^Dword' };
public function SHL { lambda (Dword,Byte) Dword:   native '<<Dword' };
public function SHR { lambda (Dword,Byte) Dword:   native '>>Dword' };
public function AND { lambda (Qword,Qword) Qword:  native '&Qword' };
public function  OR { lambda (Qword,Qword) Qword:  native '|Qword' };
public function NOT { lambda Qword Qword:          native '~Qword' };
public function XOR { lambda (Qword,Qword) Qword:  native '^Qword' };
public function SHL { lambda (Qword,Byte) Qword:   native '<<Qword' };
public function SHR { lambda (Qword,Byte) Qword:   native '>>Qword' };

// String Related Functions
public macro str! (x) := ~String from x;
public function from { lambda Int    String:  native 'String from Int' };
public function from { lambda Float  String:  native 'String from Float' };
public function from { lambda Int8   String:  native 'String from Int8' };
public function from { lambda Int16  String:  native 'String from Int16' };
public function from { lambda Int32  String:  native 'String from Int32' };
public function from { lambda Int64  String:  native 'String from Int64' };
public function from { lambda Uint8  String:  native 'String from Uint8' };
public function from { lambda Uint16 String:  native 'String from Uint16' };
public function from { lambda Uint32 String:  native 'String from Uint32' };
public function from { lambda Uint64 String:  native 'String from Uint64' };
public function from {
    lambda Complex String:
    lambda    z    let (re, im) := z, return "(# + #i)" (str! re, str! im)
};

// Effect Operators
public function then[T,E] {
    lambda(Effect[(),()], Effect[T,E]) Effect[T,E]:
    native 'effect-then-preset'
};
public function catch[T,E] {
    lambda(Effect[T,E], lambda E Effect[(),()]) Effect[T,()]:
    native 'effect-catch'
};
/*
public function map![A,B,E] {
    lambda(Effect*[A,E], lambda A B) Effect*[B,E]:
    native 'effect-map'
};
public function then[A,B,E] {
    lambda(Effect[A,()], lambda A Effect[B,E]) Effect[B,E]:
    native 'effect-then'
};
public function then*[A,B,E] {
    lambda(Effect[A,()], lambda A Effect*[B,E]) Effect*[B,E]:
    native 'effect-then*'
};
public function then*[T,E] {
    lambda(Effect[(),()], Effect*[T,E]) Effect*[T,E]:
    native 'effect-then*-preset'
};
public function next![A,B,E] {
    lambda(Effect[A,E], lambda A Effect[B,E]) Effect[B,E]:
    native 'effect-next'
};
public function next*[A,B,E] {
    lambda(Effect[A,E], lambda A Effect*[B,E]) Effect*[B,E]:
    native 'effect-next*'
};
public function map-error[T,E,F] {
    lambda(Effect[T,E], lambda E F) Effect[T,F]:
    native 'effect-map-error'
};
public function map-error[T,E,F] {
    lambda(Effect*[T,E], lambda E F) Effect*[T,F]:
    native 'effect-map-error-*'
};
*/
