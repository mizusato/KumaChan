## Action Types

/// Action*[T,E] represents an action that may return 0/finite/infinite T values
/// asynchronously or throw an E error asynchronously.
/// It is exactly the same concept as what is called Observable in ReactiveX.
type Action*[[unit] +T, [never] +E]
    native; // rx.Action

/// Action[T,E] represents an action that may return exactly one T value
/// asynchronously or throw an E error asynchronously.
/// It is a subtype of Action*[T,E] and can be regarded as a lazy Promise.
type Action [[unit] +T, [never] +E]
    protected Action*[T,E];


## Wired Components

/// Sink[T] accepts values of type T.
type Sink[-T]
    native; // rx.Sink

/// Bus[T] accepts values of type T and provides accepted T values,
/// similar to the concept of Subject in ReactiveX.
type Bus[T]
    protected Sink[T]; // rx.Bus

/// Reactive[T] represents a reactively mutable T value,
/// similar to the concept of BehaviourSubject in ReactiveX.
type Reactive[T]
    protected Bus[T]; // rx.Reactive

/// ReactiveEntity[T] is a subtype of Reactive[T],
/// which represents an independent reactive entity holding a mutable T value.
/// That is, different from the general concept of Reactive,
/// a ReactiveEntity is not derived from other Reactive values.
/// As a consequence, a ReactiveEntity can store snapshots of previous values
/// so that it is possible to perform undo/redo operations on it.
type ReactiveEntity[T]
    protected Reactive[T];  // rx.ReactiveEntity


## Auxiliary Types for Wired Components

/// ReactiveSnapshots[T] represents a structure that
/// consists of snapshots of the current undo stack and redo stack
/// of a ReactiveEntity at some point.
type ReactiveSnapshots[+T] {
    undo: Seq[T],
    redo: Seq[T]
};


## Mutable Containers

type Mutable[+T]     native;  // rx.Cell
type Buffer          native;  // rx.Buffer
type HashMap[+K,+V]  native;  // rx.StringHashMap, rx.NumberHashMap


## Wired Components Operations
# alias: <-
export function write[T]:    ( &(Sink[T],T) Action )
    native 'sink-write';
export function adapt[A,B]: ( &(Sink[A],(&(B)(A))) Sink[B] )
    native 'sink-adapt';
export function watch[T]: ( &(Bus[T]) Action*[T] )
    native 'bus-watch';
export function update[T]:   ( &(Reactive[T],(&(T)(T))) Action )
    native 'reactive-update';
export function adapt[A,B]:  ( &(Reactive[A],(&(A)(&(B)(A)))) Sink[B] )
    native 'reactive-adapt';
export function morph[A,B]:  ( &(Reactive[A],(&(A)(&(B)(A))),(&(A)(B))) Reactive[B] )
    native 'reactive-morph';
export function snapshot[T]: ( &(Reactive[T]) Action )
    native 'reactive-snapshot';
# alias: <-
export function read[T]: ( &(Reactive[T]) Action[T] )
    native 'reactive-read';
export function consume[T,X,E]: ( &(Reactive[List[T]],(&(ListKey,Action*[Number],Reactive[T])(Action*[X,E]))) Action*[Array[X],E] )
    native 'reactive-list-consume';
export function undo[T]:          ( &(ReactiveEntity[T]) Action )
    native 'reactive-entity-undo';
export function redo[T]:          ( &(ReactiveEntity[T]) Action )
    native 'reactive-entity-redo';
export function watch-diff[T]:    ( &(ReactiveEntity[T]) Action*[(ReactiveSnapshots[T],T)] )
    native 'reactive-entity-watch-diff';
export function auto-snapshot[T]: ( &(ReactiveEntity[T]) Reactive[T] )
    native 'reactive-entity-auto-snapshot';
export function callback[T]:           ( &(&(T)(Action)) Sink[T] )
    native 'callback';
export function new-bus[T]:            ( &() Action[Bus[T]] )
    native 'new-bus';
export function new-reactive[T]:       ( &(T) Action[ReactiveEntity[T]] )
    native 'new-reactive';
export function with-reactive[T, K < Action*[any,any]]:  ( &(T,(&(ReactiveEntity[T])(K))) K )
    native 'with-reactive';
export function with-auto-snapshot[T, K < Action*[any,any]]:  ( &(T,(&(Reactive[T],(Action,Action,Action*[(ReactiveSnapshots[T],T)]))(K))) K )
    native 'with-auto-snapshot';

## Mutable Containers Operations
export function new-mutable[T]: ( &() Action[Mutable[T]] )
    native 'new-mutable';
export function with-mutable[T, K < Action*[any,any]]:  ( &(T,(&(Mutable[T])(K))) K )
    native 'with-mutable';
export function get[T]: ( &(Mutable[T]) Action[T] )
    native 'mutable-get';
export function set[T]: ( &(Mutable[T],T) Action )
    native 'mutable-set';
export function swap[T]: ( &(Mutable[T],(&(T)(T))) Action )
    native 'mutable-swap';

## Action Constructors
export function with[A < Action*[any,any]]: ( &(A,Action) A )
    native 'with';
export function gen-random: ( &() Action[Float] )
    native 'gen-random';
export function gen-sequential-id: ( &() Action[String] )
    native 'gen-sequential-id';
export function crash: ( &(String) Action[never] )
    native 'crash';
export function crash: ( &(Error) Action[never] )  // TODO: add 'crash-on-error'
    ( &(err) (crash ((str err) | "Error: #")) );
export function from: ( &(Error) String )  // TODO: move this function
    native 'String from error';
export function make-error: ( &(String) Error )  // TODO: move this function
    native 'make-error';
/// go(f) returns an action that evaluates f() in a separate goroutine.
export function go[T]: ( &(&()(T)) Action[T] )
    native 'go-thunk';
/// go(seq) returns an action that iterates seq in a separate goroutine.
export function go[T]: ( &(Seq[T]) Action*[T] )
    native 'go-seq';
export function yield[T]:  ( &(T) Action[T] )
    native 'yield';
export function yield-thunk[T]: ( &(&()(T)) Action[T] )
    native 'yield-thunk';
export function yield*[T]: ( &(Seq[T]) Action*[T] )
    native 'yield*-seq';
export function yield*[T]: ( &(Array[T]) Action*[T] )
    native 'yield*-array';
export function not[E]: ( &(Action*[Bool,E]) Action*[Bool,E] )
    (&(p)(p.map not));
export function and[E]: ( &(Action*[Bool,E],Action*[Bool,E]) Action*[Bool,E] )
    (&(p,q)(computed (p,q) (&(p,q) $(p and q))));
export function or[E]: ( &(Action*[Bool,E],Action*[Bool,E]) Action*[Bool,E] )
    (&(p,q)(computed (p,q) (&(p,q) $(p or q))));
export function start-with[T,E]: ( &(Action*[T,E],Array[T]) Action*[T,E] )
    (&(e,prepended)(concat:[T,E] [(yield* prepended), e]));
export function wait: ( & {timeout:Number} Action )
    native 'wait';
export function tick: ( & {interval:Number} Action*[unit] )
    native 'tick';

## Action Operators
export function take-one-as-single[T,E]: ( &(Action*[T,E]) Action[Maybe[T],E] )
    native 'take-one-as-single';
export function wait-complete[E]: ( &(Action*[unit,E]) Action[unit,E] )
    native 'wait-complete';
export function forever[E]: ( &(Action*[unit,E]) Action[never,E] )
    native 'forever';

/// This function has two kinds of definitions:
/// 1. then(a1, r1 => a2) returns an action that performs a1 first and then
///   transforms r1 (the result of a1) into a2 and performs a2.
/// 2. then(a1, a2) returns an action that performs a1 and then performs a2.
/// In both cases, the returned action returns the result of a2.
/// Moreover, this function has an alias called `await`, which is intended
/// to be used within Flat CPS expressions.
///
# alias: await
export function then[A,B,E]: ( &(Action[A,E],(&(A)(Action[B,E]))) Action[B,E] )
    native 'then';
# alias: await
export function then[A,B,E]: ( &(Action[A,E],(&(A)(Action*[B,E]))) Action*[B,E] )
    native 'then';
# alias: await
export function then[E,B]: ( &(Action[unit,E], Action[B,E]) Action[B,E] )
    native 'then-shortcut';
# alias: await
export function then[E,B]: ( &(Action[unit,E], Action*[B,E]) Action*[B,E] )
    native 'then-shortcut';

export function catch[T,E,F]: ( &(Action[T,E],(&(E)(Action[T,F]))) Action[T,F] )
    native 'catch';
export function catch[T,E,F]: ( &(Action*[T,E],(&(E)(Action*[T,F]))) Action*[T,F] )
    native 'catch';
export function catch-retry[T,E]: ( &(Action[T,E],(&(E)(Action[Bool]))) Action[T,E] )
    native 'catch-retry';
export function catch-throw[T,E,F]: ( &(Action[T,E],(&(E)(F))) Action[T,F] )
    native 'catch-throw';
export function throw[E]: ( &(E) Action[never,E] )
    native 'throw';
export function map[A,B,E]:  ( &(Action[A,E],(&(A)(B))) Action[B,E] )
    native 'action-map';
export function map[A,B,E]: ( &(Action*[A,E],(&(A)(B))) Action*[B,E] )
    native 'action-map';
export function map-to[A,B,E]: ( &(Action[A,E],B) Action[B,E] )
    (&(e,v)(e | map (&(_)(v))));
export function map-to[A,B,E]: ( &(Action*[A,E],B) Action*[B,E] )
    (&(e,v)(e | map (&(_)(v))));
export function filter[T,E]: ( &(Action*[T,E],(&(T)(Bool))) Action*[T,E] )
    native 'action-filter';
export function filter-map[A,B,E]: ( &(Action*[A,E],(&(A)(Maybe[B]))) Action*[B,E] )
    native 'action-filter-map';
export function reduce[T,A,E]: ( &(Action*[T,E],A,(&(A,T)(A))) Action[A,E] )
    native 'action-reduce';
export function scan[T,A,E]: ( &(Action*[T,E],A,(&(A,T)(A))) Action*[A,E] )
    native 'action-scan';
export function debounce[T,E]: ( &(Action*[T,E],Number) Action*[T,E] )
    native 'debounce-time';
export function merge-map[A,B,E]: ( &(Action*[A,E],(&(A)(Action*[B,E]))) Action*[B,E] )
    native 'merge-map';
export function concat-map[A,B,E]: ( &(Action*[A,E],(&(A)(Action*[B,E]))) Action*[B,E] )
    native 'concat-map';
export function mix-map[A,B,E]: ( &(Action*[A,E],Number,(&(A)(Action*[B,E]))) Action*[B,E] )
    native 'mix-map';
export function switch-map[A,B,E]: ( &(Action*[A,E],(&(A)(Action*[B,E]))) Action*[B,E] )
    native 'switch-map';
export function merge[T,E]: ( &(Array[Action*[T,E]]) Action*[T,E] )
    native 'action-merge';
export function concat[T,E]: ( &(Array[Action*[T,E]]) Action*[T,E] )
    native 'action-concat';
export function distinct-until-changed[T,E]: implicit[Eq[T]] ( &(Action*[T,E]) Action*[T,E] )
    (&(a)(a.distinct-until-changed(=)));
export function distinct-until-changed[T,E]: ( &(Action*[T,E],(&(T,T)(Bool))) Action*[T,E] )
    native 'distinct-until-changed';
export function with-latest-from[A,B,E]: ( &(Action*[A,E],Action*[B,E]) Action*[(A,Maybe[B]),E] )
    native 'with-latest-from';
export function with-latest-from[A,B,E]: ( &(Action*[A,E],Reactive[B]) Action*[(A,B),E] )
    native 'with-latest-from-reactive';
export function combine-latest[A,B,E]:
    ( &(Action*[A,E],Action*[B,E])
        Action*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
export function combine-latest[A,B,C,E]:
    ( &(Action*[A,E],Action*[B,E],Action*[C,E])
        Action*[(Maybe[A],Maybe[B],Maybe[C]),E] )
    native 'combine-latest';
export function combine-latest[A,B,C,D,E]:
    ( &(Action*[A,E],Action*[B,E],Action*[C,E],Action*[D,E])
        Action*[(Maybe[A],Maybe[B],Maybe[C],Maybe[D]),E] )
    native 'combine-latest';
export function combine-latest*[A,B,E]:
    ( &(Action*[A,E],Action*[B,E]) Action*[(A,B),E] )
    native 'combine-latest*';
export function combine-latest*[A,B,C,E]:
    ( &(Action*[A,E],Action*[B,E],Action*[C,E]) Action*[(A,B,C),E] )
    native 'combine-latest*';
export function combine-latest*[A,B,C,D,E]:
    ( &(Action*[A,E],Action*[B,E],Action*[C,E],Action*[D,E]) Action*[(A,B,C,D),E] )
    native 'combine-latest*';
export function combine-latest*[T,E]: ( &(Array[Action*[T,E]]) Action*[Array[T],E] )
    native 'combine-latest*-array';
export function computed[A,B,E,X]:
    ( &((Action*[A,E],Action*[B,E]),(&(A,B)(X))) Action*[X,E] )
    native 'computed';
export function computed[A,B,C,E,X]:
    ( &((Action*[A,E],Action*[B,E],Action*[C,E]),(&(A,B,C)(X))) Action*[X,E] )
    native 'computed';
export function computed[A,B,C,D,E,X]:
    ( &((Action*[A,E],Action*[B,E],Action*[C,E],Action*[D,E]),(&(A,B,C,D)(X))) Action*[X,E] )
    native 'computed';
