## Action Types

/// Action*[T,E] represents an action that may return 0/finite/infinite T values
/// asynchronously or throw an E error asynchronously.
/// It is exactly the same concept as what is called Observable in ReactiveX.
type Action*[[unit] +T, [never] +E]
    native; // rx.Action

/// Action[T,E] represents an action that may return exactly one T value
/// asynchronously or throw an E error asynchronously.
/// It is a subtype of Action*[T,E] and can be regarded as a lazy Promise.
type Action [[unit] +T, [never] +E]
    protected Action*[T,E];

/// Source[T] represents an action that subscribes to a discrete data source.
type Source[+T]
    protected
    Action*[T];

/// Computed[T] represents an action that subscribes to a continuous data source.
type Computed[+T]
    protected
    Source[T];


## Wired Components

/// Sink[T] accepts values of type T.
type Sink[-T]
    native; // rx.Sink

/// Bus[T] accepts values of type T and provides accepted T values,
/// similar to the concept of Subject in ReactiveX.
type Bus[T]
    protected Sink[T]; // rx.Bus

/// Reactive[T] represents a reactively mutable T value,
/// similar to the concept of BehaviourSubject in ReactiveX.
type Reactive[T]
    protected Bus[T]; // rx.Reactive

/// ReactiveEntity[T] is a subtype of Reactive[T],
/// which represents an independent reactive entity holding a mutable T value.
/// That is, different from the general concept of Reactive,
/// a ReactiveEntity is not derived from other Reactive values.
/// As a consequence, a ReactiveEntity can store snapshots of previous values
/// so that it is possible to perform undo/redo operations on it.
type ReactiveEntity[T]
    protected Reactive[T];  // rx.ReactiveEntity


## Auxiliary Types for Wired Components

/// ReactiveSnapshots[T] represents a structure that
/// consists of snapshots of the current undo stack and redo stack
/// of a ReactiveEntity at some point.
type ReactiveSnapshots[+T] {
    undo: Seq[T],
    redo: Seq[T]
};


## Mutable Containers

type Mutable[+T]     native;  // rx.Cell
type Buffer          native;  // rx.Buffer
type HashMap[+K,+V]  native;  // rx.StringHashMap, rx.NumberHashMap


## Wired Components Operations
// TODO: to be semantic: tuple input --> bundle input
// TODO: remove connect(Action*,Sink),
//       only preserve connect(Bus,Sink)
//       change return value type to Action[never]
export function connect:[T]
    &(Source[T], Sink[T]) => Action[never]
    native 'connect';
export function connect:[T]
    &(Bus[T], Sink[T]) => Action[never]
    &(bus, sink) => ({watch(bus)} connect sink);
export function connect:[T,E]
    &(Source[T], &(T) => Action) => Action[never]
    &(source, receiver) => (source connect {callback(receiver)});
export function connect:[T,E]
    &(Bus[T], &(T) => Action) => Action[never]
    &(bus, receiver) => ({watch(bus)} connect {callback(receiver)});
export function connect:[E]
    &(Source[unit], Action) => Action[never]
    &(source, receiver) => (source connect &() => receiver);
export function connect:[E]
    &(Bus[unit], Action) => Action[never]
    &(bus, receiver) => (bus connect &() => receiver);
# alias: <-
export function write:[T]
    &(Sink[T], T) => Action
    native 'sink-write';
export function adapt:[A,B]
    &(Sink[A], &(B) => A) => Sink[B]
    native 'sink-adapt';
export function watch:[T]
    &(Bus[T]) => Source[T]
    native 'bus-watch';
export function watch:[T]
    &(Reactive[T]) => Computed[T]
    native 'bus-watch';
export function update:[T]
    &(Reactive[T], &(T) => T) => Action
    native 'reactive-update';
export function adapt:[A,B]
    &(Reactive[A], &(A) => &(B) => A) => Sink[B]
    native 'reactive-adapt';
export function morph:[A,B]
    &(Reactive[A], (&(A) => &(B) => A), (&(A) => B)) => Reactive[B]
    native 'reactive-morph';
export function snapshot:[T]
    &(Reactive[T]) => Action
    native 'reactive-snapshot';
# alias: <-
export function read:[T]
    &(Reactive[T]) => Action[T]
    native 'reactive-read';
export function consume:[T,X]
    &(Reactive[List[T]], &(ListKey,Computed[Number],Reactive[T]) => Computed[X]) => Computed[Array[X]]
    native 'reactive-list-consume';
export function undo:[T]
    &(ReactiveEntity[T]) => Action
    native 'reactive-entity-undo';
export function redo:[T]
    &(ReactiveEntity[T]) => Action
    native 'reactive-entity-redo';
export function watch-diff:[T]
    &(ReactiveEntity[T]) => Action*[(ReactiveSnapshots[T],T)]
    native 'reactive-entity-watch-diff';
export function auto-snapshot:[T]
    &(ReactiveEntity[T]) => Reactive[T]
    native 'reactive-entity-auto-snapshot';
export function blackhole:
    &() => Sink[any]
    native 'blackhole';
export function callback:[T]
    &(&(T) => Action) => Sink[T]
    native 'callback';
export function bus: [T, K < Action*[any,any]]
    &(unit, &(Bus[T]) => K) => K
    native 'bus';
export function reactive: [T, K < Action*[any,any]]
    &(T, &(ReactiveEntity[T]) => K) => K
    native 'reactive';
export function reactive+snapshot: [T, K < Action*[any,any]]
    &(T, &(Reactive[T],(Action,Action,Action*[(ReactiveSnapshots[T],T)])) => K) => K
    native 'reactive+snapshot';

## Mutable Containers Operations
export function new-mutable:[T]
    &() => Action[Mutable[T]]
    native 'new-mutable';
export function with-mutable: [T, K < Action*[any,any]]
    &(T, &(Mutable[T]) => K) => K
    native 'with-mutable';
export function get:[T]
    &(Mutable[T]) => Action[T]
    native 'mutable-get';
export function set:[T]
    &(Mutable[T], T) => Action
    native 'mutable-set';
export function swap:[T]
    &(Mutable[T], &(T) => T) => Action
    native 'mutable-swap';

## Action Constructors
export function with: [A < Action*[any,any]]
    &(A, Action) => A
    native 'with';
export function gen-random:
    &() => Action[Float]
    native 'gen-random';
export function gen-sequential-id:
    &() => Action[String]
    native 'gen-sequential-id';
export function crash:
    &(String) => Action[never]
    native 'crash';
export function crash:  // TODO: add 'crash-on-error'
    &(Error) => Action[never]
    &(err) => { crash err.{str}.{"Error: #"} };
export function convert:  // TODO: move this function
    &(Error) => String
    native 'String from error';
export function make-error:  // TODO: move this function
    &(String) => Error
    native 'make-error';
/// go(f) returns an action that evaluates f() in a separate goroutine.
export function go:[T]
    &(&() => T) => Action[T]
    native 'go-thunk';
/// go(seq) returns an action that iterates seq in a separate goroutine.
export function go:[T]
    &(Seq[T]) => Action*[T]
    native 'go-seq';
export function yield:[T]
    &(T) => Action[T]
    native 'yield';
export function yield*:[T]
    &(Seq[T]) => Action*[T]
    native 'yield*-seq';
export function yield*:[T]
    &(Array[T]) => Action*[T]
    native 'yield*-array';
export function not:[E]
    &(Computed[Bool]) => Computed[Bool]
    &(p) => p.{map(not)};
export function and:[E]
    &(Computed[Bool], Computed[Bool]) => Computed[Bool]
    &(p,q) => { computed ((p,q), &(p,q) => (p and q)) };
export function or:[E]
    &(Computed[Bool], Computed[Bool]) => Computed[Bool]
    &(p,q) => { computed ((p,q), &(p,q) => (p or q)) };
export function start-with:[T,E]
    &(Action*[T,E], Array[T]) => Action*[T,E]
    native 'start-with';
export function start-with:[T,E]
    &(Source[T], Array[T]) => Computed[T]
    native 'start-with';
export function wait:
    & { timeout: Number } => Action
    native 'wait';
export function tick:
    & { interval: Number } => Action*[unit]
    native 'tick';

## Action Operators
export function take-one-as-single:[T,E]
    &(Action*[T,E]) => Action[Maybe[T],E]
    native 'take-one-as-single';
export function wait-complete:[E]
    &(Action*[unit,E]) => Action[unit,E]
    native 'wait-complete';
export function forever:[E]
    &(Action*[unit,E]) => Action[never,E]
    native 'forever';

/// This function has two kinds of definitions:
/// 1. then(a1, r1 => a2) returns an action that performs a1 first and then
///   transforms r1 (the result of a1) into a2 and performs a2.
/// 2. then(a1, a2) returns an action that performs a1 and then performs a2.
/// In both cases, the returned action returns the result of a2.
/// Moreover, this function has an alias called `await`, which is intended
/// to be used within Flat CPS expressions.
///
# alias: await
export function then:[A,B,E]
    &(Action[A,E], &(A) => Action[B,E]) => Action[B,E]
    native 'then';
# alias: await
export function then:[A,B,E]
    &(Action[A,E], &(A) => Action*[B,E]) => Action*[B,E]
    native 'then';
# alias: await
export function then:[A,B]
    &(Action[A], &(A) => Source[B]) => Source[B]
    native 'then';
# alias: await
export function then:[A,B]
    &(Action[A], &(A) => Computed[B]) => Computed[B]
    native 'then';
# alias: await
export function then:[E,B]
    &(Action[unit,E], Action[B,E]) => Action[B,E]
    native 'then-shortcut';
# alias: await
export function then:[E,B]
    &(Action[unit,E], Action*[B,E]) => Action*[B,E]
    native 'then-shortcut';
# alias: await
export function then:[B]
    &(Action, Source[B]) => Source[B]
    native 'then-shortcut';
# alias: await
export function then:[B]
    &(Action, Computed[B]) => Computed[B]
    native 'then-shortcut';

export function catch:[T,E,F]
    &(Action[T,E], &(E) => Action[T,F]) => Action[T,F]
    native 'catch';
export function catch:[T,E,F]
    &(Action*[T,E], &(E) => Action*[T,F]) => Action*[T,F]
    native 'catch';
export function catch-retry:[T,E]
    &(Action[T,E], &(E) => Action[Bool]) => Action[T,E]
    native 'catch-retry';
export function catch-retry:[T,E]
    &(Action*[T,E], &(E) => Action[Bool]) => Action*[T,E]
    native 'catch-retry';
export function catch-throw:[T,E,F]
    &(Action[T,E], &(E) => F) => Action[T,F]
    native 'catch-throw';
export function catch-throw:[T,E,F]
    &(Action*[T,E], &(E) => F) => Action*[T,F]
    native 'catch-throw';
export function catch-crash:[T]
    &(Action[T,Error]) => Action[T]
    &(action) => action.{ catch &(err) => { crash err } };
export function catch-crash:[T]
    &(Action*[T,Error]) => Action*[T]
    &(action) => action.{ catch &(err) => { crash err } };
export function throw:[E]
    &(E) => Action[never,E]
    native 'throw';
export function map:[A,B,E]
    &(Action[A,E], &(A) => B) => Action[B,E]
    native 'action-map';
export function map:[A,B,E]
    &(Action*[A,E], &(A) => B) => Action*[B,E]
    native 'action-map';
export function map:[A,B]
    &(Source[A], &(A) => B) => Source[B]
    native 'action-map';
export function map:[A,B]
    &(Computed[A], &(A) => B) => Computed[B]
    native 'action-map';
export function map-to:[A,B,E]
    &(Action[A,E], B) => Action[B,E]
    &(e,v) => e.{map(&() => v)};
export function map-to:[A,B,E]
    &(Action*[A,E], B) => Action*[B,E]
    &(e,v) => e.{map(&() => v)};
export function filter:[T,E]
    &(Action*[T,E], &(T) => Bool) => Action*[T,E]
    native 'action-filter';
export function filter:[T]
    &(Source[T], &(T) => Bool) => Source[T]
    native 'action-filter';
export function filter-map:[A,B,E]
    &(Action*[A,E], &(A) => Maybe[B]) => Action*[B,E]
    native 'action-filter-map';
export function reduce:[T,A,E]
    &(Action*[T,E], A, &(A,T) => A) => Action[A,E]
    native 'action-reduce';
export function scan:[T,A,E]
    &(Action*[T,E], A, &(A,T) => A) => Action*[A,E]
    native 'action-scan';
export function scan:[T,A]
    &(Source[T], A, &(A,T) => A) => Source[A]
    native 'action-scan';
export function debounce:[T,E]
    &(Action*[T,E], Number) => Action*[T,E]
    native 'debounce-time';
export function debounce:[T]
    &(Source[T], Number) => Source[T]
    native 'debounce-time';
export function debounce:[T]
    &(Computed[T], Number) => Source[T]
    native 'debounce-time';
export function merge-map:[A,B,E]
    &(Action*[A,E], &(A) => Action*[B,E]) => Action*[B,E]
    native 'merge-map';
export function concat-map:[A,B,E]
    &(Action*[A,E], &(A) => Action*[B,E]) => Action*[B,E]
    native 'concat-map';
export function concat-map:[A,B]
    &(Source[A], &(A) => Action*[B]) => Source[B]
    native 'concat-map';
export function mix-map:[A,B,E]
    &(Action*[A,E], Number, &(A) => Action*[B,E]) => Action*[B,E]
    native 'mix-map';
export function switch-map:[A,B,E]
    &(Action*[A,E], &(A) => Action*[B,E]) => Action*[B,E]
    native 'switch-map';
export function switch-map:[A,B]
    &(Source[A], &(A) => Action*[B]) => Source[B]
    native 'switch-map';
export function switch-map:[A,B]
    &(Computed[A], &(A) => Computed[B]) => Computed[B]
    native 'switch-map';
export function merge:[T,E]
    &(Array[Action*[T,E]]) => Action*[T,E]
    native 'action-merge';
export function merge:[E]
    &(Array[Action[never]]) => Action[never]
    native 'action-merge';
export function merge:[T]
    &(Array[Source[T]]) => Source[T]
    native 'action-merge';
export function concat:[T,E]
    &(Array[Action*[T,E]]) => Action*[T,E]
    native 'action-concat';
export function distinct-until-changed:
    [T,E] (Eq[T])
    &(Action*[T,E]) => Action*[T,E]
    &(a) => { distinct-until-changed (a, =) };
export function distinct-until-changed:[T,E]
    &(Action*[T,E], &(T,T) => Bool) => Action*[T,E]
    native 'distinct-until-changed';
export function with-latest-from:[A,B,E]
    &(Action*[A,E], Action*[B,E]) => Action*[(A,Maybe[B]),E]
    native 'with-latest-from';
export function with-latest-from:[A,B,E]
    &(Action*[A,E], Reactive[B]) => Action*[(A,B),E]
    native 'with-latest-from-reactive';
export function combine-latest:[A,B,E]
    &(Action*[A,E], Action*[B,E]) =>
        Action*[(Maybe[A],Maybe[B]),E]
    native 'combine-latest';
export function combine-latest:[A,B,C,E]
    &(Action*[A,E],Action*[B,E],Action*[C,E]) =>
        Action*[(Maybe[A],Maybe[B],Maybe[C]),E]
    native 'combine-latest';
export function combine-latest:[A,B,C,D,E]
    &(Action*[A,E],Action*[B,E],Action*[C,E],Action*[D,E]) =>
        Action*[(Maybe[A],Maybe[B],Maybe[C],Maybe[D]),E]
    native 'combine-latest';
export function combine-latest*:[A,B,E]
    &(Action*[A,E],Action*[B,E]) => Action*[(A,B),E]
    native 'combine-latest*';
export function combine-latest*:[A,B,C,E]
    &(Action*[A,E],Action*[B,E],Action*[C,E]) => Action*[(A,B,C),E]
    native 'combine-latest*';
export function combine-latest*:[A,B,C,D,E]
    &(Action*[A,E],Action*[B,E],Action*[C,E],Action*[D,E]) => Action*[(A,B,C,D),E]
    native 'combine-latest*';
export function combine-latest*:[T,E]
    &(Array[Action*[T,E]]) => Action*[Array[T],E]
    native 'combine-latest*-array';
export function combine:[A,B]
    &(Computed[A],Computed[B]) => Computed[(A,B)]
    native 'combine-latest*';
export function combine:[A,B,C]
    &(Computed[A],Computed[B],Computed[C]) => Computed[(A,B,C)]
    native 'combine-latest*';
export function combine:[A,B,C,D]
    &(Computed[A],Computed[B],Computed[C],Computed[D]) => Computed[(A,B,C,D)]
    native 'combine-latest*';
export function combine:[T]
    &(Array[Computed[T]]) => Computed[Array[T]]
    native 'combine-latest*-array';
// TODO: consider computed (reactive1, reactive2)
export function computed:[A,B,X]
    &((Computed[A],Computed[B]), &(A,B) => X) => Computed[X]
    native 'computed';
export function computed:[A,B,C,X]
    &((Computed[A],Computed[B],Computed[C]), &(A,B,C) => X) => Computed[X]
    native 'computed';
export function computed:[A,B,C,D,X]
    &((Computed[A],Computed[B],Computed[C],Computed[D]), &(A,B,C,D) => X) => Computed[X]
    native 'computed';
