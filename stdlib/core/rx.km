## Effect Types

/// Observable[T,E] represents an effect that may return 0/finite/infinite
/// T values, or throw an E error half-way, synchronously or asynchronously.
type Observable [[unit] +T, [never] +E]
    native; // rx.Observable

/// Action[T,E] represents an effect that may return a T value,
/// or throw an E error, synchronously or asynchronously.
/// It is a subtype of Observable[T,E] and can be regarded as a lazy Promise.
type Action [[unit] +T, [never] +E]
    protected
    Observable[T,E];

/// Atomic[T] represents an effect that returns a T value synchronously.
/// It is a subtype of Action[T]. Different from general Action, an Atomic
/// is guaranteed synchronous and cannot be cancelled half-way.
/// There is a `do` function, which can be used to concatenate
/// multiple Atomic effects into a single Atomic effect.
type Atomic [[unit] T]
    protected
    Action[T];

/// Source[T] represents an effect that subscribes to a discrete data source.
/// It is a subtype of Observable[T]. Different from general Observable, a Source
/// never completes.
type Source[+T]
    protected
    Observable[T];

/// Computed[T] represents an effect that subscribes to a continuous data source.
/// It is a subtype of Source[T]. Different from general Source, a Computed
/// has a current value and always produces its current value synchronously
/// as its first value.
type Computed[+T]
    protected
    Source[T];


## Wired Components

/// Sink[T] accepts values of type T.
type Sink[-T]
    native; // rx.Sink

/// Bus[T] accepts values of type T and provides accepted T values,
/// similar to the concept of Subject in ReactiveX.
type Bus[T]
    protected Sink[T]; // rx.Bus

/// Reactive[T] represents a reactively mutable T value,
/// similar to the concept of BehaviourSubject in ReactiveX.
type Reactive[T]
    protected Bus[T]; // rx.Reactive

/// ReactiveEntity[T] is a subtype of Reactive[T],
/// which represents an independent reactive entity holding a mutable T value.
/// That is, different from the general concept of Reactive,
/// a ReactiveEntity is not derived from other Reactive values.
/// As a consequence, a ReactiveEntity can store snapshots of previous values
/// so that it is possible to perform undo/redo operations on it.
type ReactiveEntity[T]
    protected Reactive[T];  // rx.ReactiveEntity


## Auxiliary Types for Wired Components

/// ReactiveSnapshots[T] represents a structure that
/// consists of snapshots of the current undo stack and redo stack
/// of a ReactiveEntity at some point.
type ReactiveSnapshots[+T] {
    undo: Seq[T],
    redo: Seq[T]
};


## Lock Types

type Mutex[+T]
    native;


## Mutable Containers

type Mutable[+T]     native;  // rx.Cell
type Buffer          native;  // rx.Buffer
type HashMap[+K,+V]  native;  // rx.StringHashMap, rx.NumberHashMap


## Wired Components Operations
export function connect:[T]
    &(Source[T], Sink[T]) => Action[never]
    native 'connect';
export function connect:[T]
    &(Bus[T], Sink[T]) => Action[never]
    &(bus, sink) => ({watch(bus)} connect sink);
export function connect:[T,E]
    &(Source[T], &(T) => Action) => Action[never]
    &(source, receiver) => (source connect {Callback(receiver)});
export function connect:[T,E]
    &(Bus[T], &(T) => Action) => Action[never]
    &(bus, receiver) => ({watch(bus)} connect {Callback(receiver)});
export function connect:[E]
    &(Source[unit], Action) => Action[never]
    &(source, receiver) => (source connect &() => receiver);
export function connect:[E]
    &(Bus[unit], Action) => Action[never]
    &(bus, receiver) => (bus connect &() => receiver);
# alias: <-
export function write:[T]
    &(Sink[T], T) => Atomic
    native 'sink-write';
export function adapt:[A,B]
    &(Sink[A], &(B) => A) => Sink[B]
    native 'sink-adapt';
export function watch:[T]
    &(Bus[T]) => Source[T]
    native 'bus-watch';
export function watch:[T]
    &(Reactive[T]) => Computed[T]
    native 'bus-watch';
export function update:[T]
    &(Reactive[T], &(T) => T) => Atomic
    native 'reactive-update';
export function adapt:[A,B]
    &(Reactive[A], &(A) => &(B) => A) => Sink[B]
    native 'reactive-adapt';
export function morph:[A,B]
    &(Reactive[A], (&(A) => &(B) => A), (&(A) => B)) => Reactive[B]
    native 'reactive-morph';
export function snapshot:[T]
    &(Reactive[T]) => Atomic
    native 'reactive-snapshot';
# alias: <-
export function read:[T]
    &(Reactive[T]) => Atomic[T]
    native 'reactive-read';
// TODO: should provide bundle instead of tuple
export function consume:[T,X]
    &(Reactive[List[T]], &(ListKey,Computed[Number],Reactive[T]) => Computed[X]) => Computed[Array[X]]
    native 'reactive-list-consume';
export function undo:[T]
    &(ReactiveEntity[T]) => Atomic
    native 'reactive-entity-undo';
export function redo:[T]
    &(ReactiveEntity[T]) => Atomic
    native 'reactive-entity-redo';
export function watch-diff:[T]
    &(ReactiveEntity[T]) => Observable[(ReactiveSnapshots[T],T)]
    native 'reactive-entity-watch-diff';
export function auto-snapshot:[T]
    &(ReactiveEntity[T]) => Reactive[T]
    native 'reactive-entity-auto-snapshot';
export function Blackhole:
    &() => Sink[any]
    native 'Blackhole';
export function Callback:[T]
    &(&(T) => Action) => Sink[T]
    native 'Callback';
export function create-bus:[T]
    &() => Atomic[Bus[T]]
    native 'create-bus';
export function create-reactive:[T]
    &(T) => Atomic[ReactiveEntity[T]]
    native 'create-reactive';

## Mutable Containers Operations
export function new-mutable:[T]
    &() => Action[Mutable[T]]
    native 'new-mutable';
export function with-mutable: [T, K < Observable[any,any]]
    &(T, &(Mutable[T]) => K) => K
    native 'with-mutable';
export function get:[T]
    &(Mutable[T]) => Action[T]
    native 'mutable-get';
export function set:[T]
    &(Mutable[T], T) => Action
    native 'mutable-set';
export function swap:[T]
    &(Mutable[T], &(T) => T) => Action
    native 'mutable-swap';

## Locks Operations
export function mutex: [T, K < Observable[any,any]]
    &(T, &(Mutex[T]) => K) => K
    native 'mutex';
export function lock: [T, K < Observable[any]]
    &(Mutex[T], &(T) => K) => K
    native 'mutex-lock';

## Effect Constructors
export function as-source:[T]
    &(Observable[T]) => Source[T]
    native 'as-source';
export function with: [A < Observable[any,any]]
    &(A, Action) => A
    native 'with';
export function gen-random:
    &() => Atomic[Float]
    native 'gen-random';
export function gen-monotonic-id:
    &() => Atomic[Uint64]
    native 'gen-monotonic-id';
export function gen-monotonic-id-string:
    &() => Atomic[String]
    native 'gen-monotonic-id-string';
export function crash:
    &(String) => Action[never]
    native 'crash';
export function crash:
    &(Error) => Action[never]
    &(err) => { crash err.{str}.{"Error: #"} };
export function convert:  // TODO: move this function
    &(Error) => String
    native 'String from error';
export function make-error:  // TODO: move this function
    &(String) => Error
    native 'make-error';
/// go(f) returns an action that evaluates f() in a separate goroutine.
export function go:[T]
    &(&() => T) => Action[T]
    native 'go-thunk';
/// go(seq) returns an action that iterates seq in a separate goroutine.
export function go:[T]
    &(Seq[T]) => Observable[T]
    native 'go-seq';
export function yield:[T]
    &(T) => Atomic[T]
    native 'yield';
export function yield*:[T]
    &(Seq[T]) => Observable[T]
    native 'yield*-seq';
export function yield*:[T]
    &(Array[T]) => Observable[T]
    native 'yield*-array';
export function not:[E]
    &(Computed[Bool]) => Computed[Bool]
    &(p) => p.{map(not)};
export function and:[E]
    &(Computed[Bool], Computed[Bool]) => Computed[Bool]
    &(p,q) => { computed ((p,q), &(p,q) => (p and q)) };
export function or:[E]
    &(Computed[Bool], Computed[Bool]) => Computed[Bool]
    &(p,q) => { computed ((p,q), &(p,q) => (p or q)) };
export function start-with:[T,E]
    &(Observable[T,E], Array[T]) => Observable[T,E]
    native 'start-with';
export function start-with:[T,E]
    &(Source[T], Array[T]) => Computed[T]
    native 'start-with';
export function wait:
    & { timeout: Number } => Action
    native 'wait';
export function tick:
    & { interval: Number } => Observable[unit]
    native 'tick';

## Effect Operators
# alias: <-
export function read:[T]
    &(Computed[T]) => Atomic[T]
    native 'computed-read';
export function take-one-as-single:[T,E]
    &(Observable[T,E]) => Action[Maybe[T],E]
    native 'take-one-as-single';
export function wait-complete:[E]
    &(Observable[unit,E]) => Action[unit,E]
    native 'wait-complete';
export function forever:[E]
    &(Observable[unit,E]) => Action[never,E]
    native 'forever';

/// This function has two kinds of definitions:
/// 1. then(a1, r1 => a2) returns an action that performs a1 first and then
///   transforms r1 (the result of a1) into a2 and performs a2.
/// 2. then(a1, a2) returns an action that performs a1 and then performs a2.
/// In both cases, the returned action returns the result of a2.
/// Moreover, this function has an alias called `await`, which is intended
/// to be used within Flat CPS expressions.
///
# alias: await
export function then:[A,B,E]
    &(Action[A,E], &(A) => Action[B,E]) => Action[B,E]
    native 'then';
# alias: await
export function then:[A,B,E]
    &(Action[A,E], &(A) => Observable[B,E]) => Observable[B,E]
    native 'then';
# alias: await
export function then:[A,B]
    &(Action[A], &(A) => Source[B]) => Source[B]
    native 'then';
# alias: await
export function then:[E,B]
    &(Action[unit,E], Action[B,E]) => Action[B,E]
    native 'then-shortcut';
# alias: await
export function then:[E,B]
    &(Action[unit,E], Observable[B,E]) => Observable[B,E]
    native 'then-shortcut';
# alias: await
export function then:[B]
    &(Action, Source[B]) => Source[B]
    native 'then-shortcut';

export function do: [A, K < Observable[any,any]]
    &(Atomic[A], &(A) => K) => K
    native 'do';
export function do: [K < Observable[any,any]]
    &(Atomic, K) => K
    native 'do-shortcut';

export function catch:[T,E,F]
    &(Action[T,E], &(E) => Action[T,F]) => Action[T,F]
    native 'catch';
export function catch:[T,E,F]
    &(Observable[T,E], &(E) => Observable[T,F]) => Observable[T,F]
    native 'catch';
export function catch-retry:[T,E]
    &(Action[T,E], &(E) => Action[Bool]) => Action[T,E]
    native 'catch-retry';
export function catch-retry:[T,E]
    &(Observable[T,E], &(E) => Action[Bool]) => Observable[T,E]
    native 'catch-retry';
export function catch-throw:[T,E,F]
    &(Action[T,E], &(E) => F) => Action[T,F]
    native 'catch-throw';
export function catch-throw:[T,E,F]
    &(Observable[T,E], &(E) => F) => Observable[T,F]
    native 'catch-throw';
export function crash-on-error:[T]
    &(Action[T,Error]) => Action[T]
    &(action) => action.{ catch &(err) => { crash err } };
export function crash-on-error:[T]
    &(Observable[T,Error]) => Observable[T]
    &(action) => action.{ catch &(err) => { crash err } };
export function throw:[E]
    &(E) => Action[never,E]
    native 'throw';
export function map:[A,B,E]
    &(Action[A,E], &(A) => B) => Action[B,E]
    native 'action-map';
export function map:[A,B,E]
    &(Observable[A,E], &(A) => B) => Observable[B,E]
    native 'action-map';
export function map:[A,B]
    &(Source[A], &(A) => B) => Source[B]
    native 'action-map';
export function map:[A,B]
    &(Computed[A], &(A) => B) => Computed[B]
    native 'action-map';
export function map-to:[A,B,E]
    &(Action[A,E], B) => Action[B,E]
    &(e,v) => e.{map(&() => v)};
export function map-to:[A,B,E]
    &(Observable[A,E], B) => Observable[B,E]
    &(e,v) => e.{map(&() => v)};
export function filter:[T,E]
    &(Observable[T,E], &(T) => Bool) => Observable[T,E]
    native 'action-filter';
export function filter:[T]
    &(Source[T], &(T) => Bool) => Source[T]
    native 'action-filter';
export function filter-map:[A,B,E]
    &(Observable[A,E], &(A) => Maybe[B]) => Observable[B,E]
    native 'action-filter-map';
export function reduce:[T,A,E]
    &(Observable[T,E], A, &(A,T) => A) => Action[A,E]
    native 'action-reduce';
export function scan:[T,A,E]
    &(Observable[T,E], A, &(A,T) => A) => Observable[A,E]
    native 'action-scan';
export function scan:[T,A]
    &(Source[T], A, &(A,T) => A) => Source[A]
    native 'action-scan';
export function debounce:[T,E]
    &(Observable[T,E], Number) => Observable[T,E]
    native 'debounce-time';
export function debounce:[T]
    &(Source[T], Number) => Source[T]
    native 'debounce-time';
export function debounce:[T]
    &(Computed[T], Number) => Source[T]
    native 'debounce-time';
export function merge-map:[A,B,E]
    &(Observable[A,E], &(A) => Observable[B,E]) => Observable[B,E]
    native 'merge-map';
export function concat-map:[A,B,E]
    &(Observable[A,E], &(A) => Observable[B,E]) => Observable[B,E]
    native 'concat-map';
export function concat-map:[A,B]
    &(Source[A], &(A) => Observable[B]) => Source[B]
    native 'concat-map';
export function mix-map:[A,B,E]
    &(Observable[A,E], Number, &(A) => Observable[B,E]) => Observable[B,E]
    native 'mix-map';
export function switch-map:[A,B,E]
    &(Observable[A,E], &(A) => Observable[B,E]) => Observable[B,E]
    native 'switch-map';
export function switch-map:[A,B]
    &(Source[A], &(A) => Observable[B]) => Source[B]
    native 'switch-map';
export function switch-map:[A,B]
    &(Computed[A], &(A) => Computed[B]) => Computed[B]
    native 'switch-map';
export function merge:[T,E]
    &(Array[Observable[T,E]]) => Observable[T,E]
    native 'action-merge';
export function merge:[E]
    &(Array[Action[never]]) => Action[never]
    native 'action-merge';
export function merge:[T]
    &(Array[Source[T]]) => Source[T]
    native 'action-merge';
export function concat:[T,E]
    &(Array[Observable[T,E]]) => Observable[T,E]
    native 'action-concat';
export function distinct-until-changed:
    [T,E] (Eq[T])
    &(Observable[T,E]) => Observable[T,E]
    &(a) => { distinct-until-changed (a, =) };
export function distinct-until-changed:
    [T] (Eq[T])
    &(Source[T]) => Source[T]
    &(a) => { distinct-until-changed (a, =) };
export function distinct-until-changed:
    [T] (Eq[T])
    &(Computed[T]) => Computed[T]
    &(a) => { distinct-until-changed (a, =) };
export function distinct-until-changed:[T,E]
    &(Observable[T,E], &(T,T) => Bool) => Observable[T,E]
    native 'distinct-until-changed';
export function distinct-until-changed:[T]
    &(Source[T], &(T,T) => Bool) => Source[T]
    native 'distinct-until-changed';
export function distinct-until-changed:[T]
    &(Computed[T], &(T,T) => Bool) => Computed[T]
    native 'distinct-until-changed';
export function with-latest-from:[A,B,E]
    &(Observable[A,E], Observable[B,E]) => Observable[(A,Maybe[B]),E]
    native 'with-latest-from';
export function with-latest-from:[A,B,E]
    &(Observable[A,E], Reactive[B]) => Observable[(A,B),E]
    native 'with-latest-from-reactive';
export function combine-latest:[A,B,E]
    &(Observable[A,E], Observable[B,E]) =>
        Observable[(Maybe[A],Maybe[B]),E]
    native 'combine-latest';
export function combine-latest:[A,B,C,E]
    &(Observable[A,E],Observable[B,E],Observable[C,E]) =>
        Observable[(Maybe[A],Maybe[B],Maybe[C]),E]
    native 'combine-latest';
export function combine-latest:[A,B,C,D,E]
    &(Observable[A,E],Observable[B,E],Observable[C,E],Observable[D,E]) =>
        Observable[(Maybe[A],Maybe[B],Maybe[C],Maybe[D]),E]
    native 'combine-latest';
export function combine-latest*:[A,B,E]
    &(Observable[A,E],Observable[B,E]) => Observable[(A,B),E]
    native 'combine-latest*';
export function combine-latest*:[A,B,C,E]
    &(Observable[A,E],Observable[B,E],Observable[C,E]) => Observable[(A,B,C),E]
    native 'combine-latest*';
export function combine-latest*:[A,B,C,D,E]
    &(Observable[A,E],Observable[B,E],Observable[C,E],Observable[D,E]) => Observable[(A,B,C,D),E]
    native 'combine-latest*';
export function combine-latest*:[T,E]
    &(Array[Observable[T,E]]) => Observable[Array[T],E]
    native 'combine-latest*-array';
export function combine:[A,B]
    &(Computed[A],Computed[B]) => Computed[(A,B)]
    native 'combine-latest*';
export function combine:[A,B,C]
    &(Computed[A],Computed[B],Computed[C]) => Computed[(A,B,C)]
    native 'combine-latest*';
export function combine:[A,B,C,D]
    &(Computed[A],Computed[B],Computed[C],Computed[D]) => Computed[(A,B,C,D)]
    native 'combine-latest*';
export function combine:[T]
    &(Array[Computed[T]]) => Computed[Array[T]]
    native 'combine-latest*-array';
export function computed:[A,B,X]
    &((Computed[A],Computed[B]), &(A,B) => X) => Computed[X]
    native 'computed';
export function computed:[A,B,C,X]
    &((Computed[A],Computed[B],Computed[C]), &(A,B,C) => X) => Computed[X]
    native 'computed';
export function computed:[A,B,C,D,X]
    &((Computed[A],Computed[B],Computed[C],Computed[D]), &(A,B,C,D) => X) => Computed[X]
    native 'computed';
