// Effect Types
type Effect*[+T,+E]  native;  // rx.Effect       (Observable<T,E>)
type Effect[+T,+E]   protected Effect*[T,E];  // (() => Promise<T,E>)
type NoExcept*[+T]   native;  // rx.Effect       (Observable<T>)
type NoExcept[+T]    protected NoExcept*[T];  // (() => Promise<T>)

// Wired Components
type Source[+T]      native;  // rx.Source
type Sink[-T]        native;  // rx.Sink
type Bus[T]          native;  // rx.Bus   (PublishSubject<T>)
type Latch[T]        native;  // rx.Latch (BehaviorSubject<T>)

// Mutable Containers
type Mutable[+T]     native;  // rx.Cell
type List[+T]        native;  // rx.List
type Buffer          native;  // rx.Buffer
type HashMap[+K,+V]  native;  // rx.StringHashMap, rx.NumberHashMap

// Operations of Source and Sink
public function receive[T]: ( &(Source[T]) NoExcept*[T] )
    native 'receive';
public function send[T]:    ( &(Sink[T],T) NoExcept[-] )
    native 'send';
public function map[A,B]:   ( &(Source[A],(&(A)(B))) Source[B] )
    native 'source-map';
public function adapt[A,B]: ( &(Sink[A],(&(B)(A))) Sink[B] )
    native 'sink-adapt';
public function from[T]: ( &(Bus[T]) Source[T] )
    native 'Source from *';
public function from[T]: ( &(Bus[T]) Sink[T] )
    native 'Sink from *';
public function from[T]: ( &(Latch[T]) Source[T] )
    native 'Source from *';
public function from[T]: ( &(Latch[T]) Sink[T] )
    native 'Sink from *';

// Operations of Bus and Latch
public function new-bus[T]: ( &() NoExcept[Bus[T]] )
    native 'new-bus';
public function as-source[T]: ( &(Bus[T]) Source[T] )
    native 'Source from *';
public function as-sink[T]:   ( &(Bus[T]) Sink[T] )
    native 'Sink from *';
public function receive[T]: ( &(Bus[T])  NoExcept*[T] )
    native 'receive';
public function send[T]:    ( &(Bus[T],T) NoExcept[-] )
    native 'send';
public function map[A,B]:   ( &(Bus[A],(&(A)(B))) Source[B] )
    native 'source-map';
public function adapt[A,B]: ( &(Bus[A],(&(B)(A))) Sink[B] )
    native 'sink-adapt';
public function new-latch[T]: ( &(T) NoExcept[Latch[T]] )
    native 'new-latch';
public function as-source[T]: ( &(Latch[T]) Source[T] )
    native 'Source from *';
public function as-sink[T]:   ( &(Latch[T]) Sink[T] )
    native 'Sink from *';
public function receive[T]: ( &(Latch[T])  NoExcept*[T] )
    native 'receive';
public function send[T]:    ( &(Latch[T],T) NoExcept[-] )
    native 'send';
public function map[A,B]:   ( &(Latch[A],(&(A)(B))) Source[B] )
    native 'source-map';
public function adapt[A,B]: ( &(Latch[A],(&(A)(&(B)(A)))) Sink[B] )
    native 'latch-adapt';
public function reset[T]: ( &(Latch[T]) NoExcept[-] )
    native 'latch-reset';
public function combine[A,B]: ( &(Latch[A],Latch[B]) Source[(A,B)] )
    native 'latch-combine';
public function combine[A,B,C]: ( &(Latch[A],Latch[B],Latch[C]) Source[(A,B,C)] )
    native 'latch-combine';
public function combine[A,B,C,D]: ( &(Latch[A],Latch[B],Latch[C],Latch[D]) Source[(A,B,C,D)] )
    native 'latch-combine';
public function combine[A,B,C,D,E]: ( &(Latch[A],Latch[B],Latch[C],Latch[D],Latch[E]) Source[(A,B,C,D,E)] )
    native 'latch-combine';

// Mutable Cell Operations
public function new-mutable[T]: ( &() NoExcept[Mutable[T]] )
    native 'new-mutable';
public function get[T]: ( &(Mutable[T]) NoExcept[T] )
    native 'mutable-get';
public function set[T]: ( &(Mutable[T],T) NoExcept[-] )
    native 'mutable-set';
public function swap[T]: ( &(Mutable[T],(&(T)(T))) NoExcept[-] )
    native 'mutable-swap';

// Effect Constructors
public function random: ( &() NoExcept[Float] )
    native 'random';
public function crash: ( &(String) NoExcept[-] )
    native 'crash';
public function emit[T]:  ( &(T) NoExcept[T] )
    native 'emit';
public function emit*:    ( &(Range) NoExcept*[Number] )
    native 'emit*-range';
public function emit*[T]: ( &(Seq[T]) NoExcept*[T] )
    native 'emit*-seq';
public function emit*[T]: ( &(Array[T]) NoExcept*[T] )
    native 'emit*-array';
public function wait: ( & {timeout:Number} NoExcept[-] )
    native 'wait';
public function tick: ( & {interval:Number} NoExcept*[-] )
    native 'tick';
public function adapt-no-except[T,E]:  ( &(NoExcept[T]) Effect[T,E] )
    native 'adapt-no-except';
public function adapt-no-except*[T,E]: ( &(NoExcept*[T]) Effect*[T,E] )
    native 'adapt-no-except';

// Effect Operators
public function take-one[T,E]: ( &(Effect*[T,E]) Effect[Maybe[T],E] )
    native 'take-one';
public function take-one[T]:   ( &(NoExcept*[T]) NoExcept[Maybe[T]] )
    native 'take-one';
public function wait-complete[E]: ( &(Effect*[-,E]) Effect[-,E] )
    native 'wait-complete';
public function wait-complete:    ( &(NoExcept*[-]) NoExcept[-] )
    native 'wait-complete';
public function forever[E]: ( &(Effect*[-,E]) Effect[-,E] )
    native 'forever';
public function forever:    ( &(NoExcept*[-]) NoExcept[-] )
    native 'forever';
public function then[A,B,E]: ( &(Effect[A,E],(&(A)(Effect[B,E]))) Effect[B,E] )
    native 'then';
public function then[A,B,E]: ( &(Effect[A,E],(&(A)(NoExcept[B]))) Effect[B,E] )
    native 'then';
public function then[A,B,E]: ( &(NoExcept[A],(&(A)(Effect[B,E]))) Effect[B,E] )
    native 'then';
public function then[A,B]:   ( &(NoExcept[A],(&(A)(NoExcept[B]))) NoExcept[B] )
    native 'then';
public function then[B,E]: ( &(Effect[-,E], Effect[B,E]) Effect[B,E] )
    native 'then-shortcut';
public function then[B,E]: ( &(Effect[-,E], NoExcept[B]) Effect[B,E] )
    native 'then-shortcut';
public function then[B,E]: ( &(NoExcept[-], Effect[B,E]) Effect[B,E] )
    native 'then-shortcut';
public function then[B]:   ( &(NoExcept[-], NoExcept[B]) NoExcept[B] )
    native 'then-shortcut';
public function catch[T,E,F]: ( &(Effect[T,E],(&(E)(Effect[T,F]))) Effect[T,F] )
    native 'catch';
public function catch[T,E]: ( &(Effect[T,E],(&(E)(NoExcept[T]))) NoExcept[T] )
    native 'catch';
public function catch*[T,E,F]: ( &(Effect*[T,E],(&(E)(Effect*[T,F]))) Effect*[T,F] )
    native 'catch';
public function catch*[T,E]: ( &(Effect*[T,E],(&(E)(NoExcept*[T]))) NoExcept*[T] )
    native 'catch';
public function catch-retry[T,E]: ( &(Effect[T,E],(&(E)(NoExcept[Bool]))) Effect[T,E] )
    native 'catch-retry';
public function catch-throw[T,E,F]: ( &(Effect[T,E],(&(E)(F))) Effect[T,F] )
    native 'catch-throw';
public function throw[T,E]: ( &(E) Effect[T,E] )
    native 'throw';
public function map[A,B,E]:  ( &(Effect[A,E],(&(A)(B))) Effect[B,E] )
    native 'effect-map';
public function map[A,B]:    ( &(NoExcept[A],(&(A)(B))) NoExcept[B] )
    native 'effect-map';
public function map-to[A,B,E]: ( &(Effect[A,E],B) Effect[B,E] )
    (&(e,v)(e | map (&(_)(v))));
public function map-to[A,B]: ( &(NoExcept[A],B) NoExcept[B] )
    (&(e,v)(e | map (&(_)(v))));
public function map*[A,B,E]: ( &(Effect*[A,E],(&(A)(B))) Effect*[B,E] )
    native 'effect-map';
public function map*[A,B]:   ( &(NoExcept*[A],(&(A)(B))) NoExcept*[B] )
    native 'effect-map';
public function map*-to[A,B,E]: ( &(Effect*[A,E],B) Effect*[B,E] )
    (&(e,v)(e | map* (&(_)(v))));
public function map*-to[A,B]: ( &(NoExcept*[A],B) NoExcept*[B] )
    (&(e,v)(e | map* (&(_)(v))));
public function filter[T,E]: ( &(Effect*[T,E],(&(T)(Bool))) Effect*[T,E] )
    native 'effect-filter';
public function filter[T]:   ( &(NoExcept*[T],(&(T)(Bool))) NoExcept*[T] )
    native 'effect-filter';
public function reduce[T,A,E]: ( &(Effect*[T,E],A,(&(A,T)(A))) Effect[A,E] )
    native 'effect-reduce';
public function reduce[T,A]:   ( &(NoExcept*[T],A,(&(A,T)(A))) NoExcept[A] )
    native 'effect-reduce';
public function scan[T,A,E]: ( &(Effect*[T,E],A,(&(A,T)(A))) Effect*[A,E] )
    native 'effect-scan';
public function scan[T,A]:   ( &(NoExcept*[T],A,(&(A,T)(A))) NoExcept*[A] )
    native 'effect-scan';
public function debounce[T,E]: ( &(Effect*[T,E],Number) Effect*[T,E] )
    native 'debounce-time';
public function debounce[T]:   ( &(NoExcept*[T],Number) NoExcept*[T] )
    native 'debounce-time';
public function merge-map[A,B,E]: ( &(Effect*[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'merge-map';
public function merge-map[A,B,E]: ( &(Effect*[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'merge-map';
public function merge-map[A,B,E]: ( &(NoExcept*[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'merge-map';
public function merge-map[A,B]:   ( &(NoExcept*[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'merge-map';
public function concat-map[A,B,E]: ( &(Effect*[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'concat-map';
public function concat-map[A,B,E]: ( &(Effect*[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'concat-map';
public function concat-map[A,B,E]: ( &(NoExcept*[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'concat-map';
public function concat-map[A,B]:   ( &(NoExcept*[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'concat-map';
public function mix-map[A,B,E]: ( &(Effect*[A,E],Number,(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'mix-map';
public function mix-map[A,B,E]: ( &(Effect*[A,E],Number,(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'mix-map';
public function mix-map[A,B,E]: ( &(NoExcept*[A],Number,(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'mix-map';
public function mix-map[A,B]:   ( &(NoExcept*[A],Number,(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'mix-map';
public function switch-map[A,B,E]: ( &(Effect*[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function switch-map[A,B,E]: ( &(Effect*[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'switch-map';
public function switch-map[A,B,E]: ( &(NoExcept*[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function switch-map[A,B]:   ( &(NoExcept*[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'switch-map';
public function then*[A,B,E]: ( &(Effect[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function then*[A,B,E]: ( &(Effect[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'switch-map';
public function then*[A,B,E]: ( &(NoExcept[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function then*[A,B]:   ( &(NoExcept[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'switch-map';
public function merge[T,E]: ( &(Array[Effect*[T,E]]) Effect*[T,E] )
    native 'effect-merge';
public function merge[T]:   ( &(Array[NoExcept*[T]]) NoExcept*[T] )
    native 'effect-merge';
public function concat[T,E]: ( &(Array[Effect*[T,E]]) Effect*[T,E] )
    native 'effect-concat';
public function concat[T]:   ( &(Array[NoExcept*[T]]) NoExcept*[T] )
    native 'effect-concat';
public function with-latest-from[A,B,E]: ( &(Effect*[A,E],Effect*[B,E]) Effect*[(A,Maybe[B]),E] )
    native 'with-latest-from';
public function with-latest-from[A,B,E]: ( &(Effect*[A,E],NoExcept*[B]) Effect*[(A,Maybe[B]),E] )
    native 'with-latest-from';
public function with-latest-from[A,B,E]: ( &(NoExcept*[A],Effect*[B,E]) Effect*[(A,Maybe[B]),E] )
    native 'with-latest-from';
public function with-latest-from[A,B]:   ( &(NoExcept*[A],NoExcept*[B]) NoExcept*[(A,Maybe[B])] )
    native 'with-latest-from';
public function combine-latest[A,B,E]: ( &(Effect*[A,E],Effect*[B,E]) Effect*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
public function combine-latest[A,B,E]: ( &(Effect*[A,E],NoExcept*[B]) Effect*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
public function combine-latest[A,B,E]: ( &(NoExcept*[A],Effect*[B,E]) Effect*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
public function combine-latest[A,B]:   ( &(NoExcept*[A],NoExcept*[B]) NoExcept*[(Maybe[A],Maybe[B])] )
    native 'combine-latest';
public function combine-latest[A,B,C]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C])
        NoExcept*[(Maybe[A],Maybe[B],Maybe[C])] )
    native 'combine-latest';
public function combine-latest[A,B,C,D]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C],NoExcept*[D])
        NoExcept*[(Maybe[A],Maybe[B],Maybe[C],Maybe[D])] )
    native 'combine-latest';
public function combine-latest[A,B,C,D,E]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C],NoExcept*[D],NoExcept*[E])
        NoExcept*[(Maybe[A],Maybe[B],Maybe[C],Maybe[D],Maybe[E])] )
    native 'combine-latest';
