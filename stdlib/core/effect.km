// Effect Types
type Effect*[+T,+E]  native;  // rx.Effect       (Observable<T,E>)
type Effect[+T,+E]   protected Effect*[T,E];  // (() => Promise<T,E>)
type NoExcept*[+T]   native;  // rx.Effect       (Observable<T>)
type NoExcept[+T]    protected NoExcept*[T];  // (() => Promise<T>)

// Wired Components
type Sink[-T]     native;             // rx.Sink
type Bus[T]       protected Sink[T];  // rx.Bus            (Subject<T>)
type Reactive[T]  protected Bus[T];   // rx.PublishSubject (BehaviorSubject<T>)

// Mutable Containers
type Mutable[+T]     native;  // rx.Cell
type List[+T]        native;  // rx.List
type Buffer          native;  // rx.Buffer
type HashMap[+K,+V]  native;  // rx.StringHashMap, rx.NumberHashMap

// Wired Components Operations
public function emit[T]:    ( &(Sink[T],T) NoExcept[-] )
    native 'sink-emit';
public function adapt[A,B]: ( &(Sink[A],(&(B)(A))) Sink[B] )
    native 'sink-adapt';
public function watch[T]:   ( &(Bus[T]) NoExcept*[T] )
    native 'bus-watch';
public function update[T]:  ( &(Reactive[T],(&(T)(T))) NoExcept[-] )
    native 'reactive-update';
public function adapt[A,B]: ( &(Reactive[A],(&(A)(&(B)(A)))) Sink[B] )
    native 'reactive-adapt';
public function morph[A,B]: ( &(Reactive[A],(&(A)(&(B)(A))),(&(A)(B))) Reactive[B] )
    native 'reactive-morph';
public function callback[T]:           ( &(&(T)(NoExcept[-])) Sink[T] )
    native 'callback';
public function new-bus[T]:            ( &() NoExcept[Bus[T]] )
    native 'new-bus';
public function new-reactive[T]:       ( &(T) NoExcept[Reactive[T]] )
    native 'new-reactive';
public function with-reactive[T,X,E]:  ( &(T,(&(Reactive[T])(Effect[X,E]))) Effect[X,E] )
    native 'with-reactive';
public function with-reactive[T,X]:    ( &(T,(&(Reactive[T])(NoExcept[X]))) NoExcept[X] )
    native 'with-reactive';
public function with-reactive*[T,X,E]: ( &(T,(&(Reactive[T])(Effect*[X,E]))) Effect*[X,E] )
    native 'with-reactive';
public function with-reactive*[T,X]:   ( &(T,(&(Reactive[T])(NoExcept*[X]))) NoExcept*[X] )
    native 'with-reactive';

// Mutable Containers Operations
public function new-mutable[T]: ( &() NoExcept[Mutable[T]] )
    native 'new-mutable';
public function with-mutable[T,X,E]:  ( &(T,(&(Mutable[T])(Effect[X,E]))) Effect[X,E] )
    native 'with-mutable';
public function with-mutable[T,X]:    ( &(T,(&(Mutable[T])(NoExcept[X]))) NoExcept[X] )
    native 'with-mutable';
public function with-mutable*[T,X,E]: ( &(T,(&(Mutable[T])(Effect*[X,E]))) Effect*[X,E] )
    native 'with-mutable';
public function with-mutable*[T,X]:   ( &(T,(&(Mutable[T])(NoExcept*[X]))) NoExcept*[X] )
    native 'with-mutable';
public function get[T]: ( &(Mutable[T]) NoExcept[T] )
    native 'mutable-get';
public function set[T]: ( &(Mutable[T],T) NoExcept[-] )
    native 'mutable-set';
public function swap[T]: ( &(Mutable[T],(&(T)(T))) NoExcept[-] )
    native 'mutable-swap';

// Effect Constructors
public function random: ( &() NoExcept[Float] )
    native 'random';
public function crash: ( &(String) NoExcept[-] )
    native 'crash';
public function yield[T]:  ( &(T) NoExcept[T] )
    native 'yield';
public function yield*:    ( &(Range) NoExcept*[Number] )
    native 'yield*-range';
public function yield*[T]: ( &(Seq[T]) NoExcept*[T] )
    native 'yield*-seq';
public function yield*[T]: ( &(Array[T]) NoExcept*[T] )
    native 'yield*-array';
public function start-with[T]:   ( &(NoExcept*[T],Array[T]) NoExcept*[T] )
    (&(e,prepended)(concat [(yield* prepended), e]));
public function start-with[T,E]: ( &(Effect*[T,E],Array[T]) Effect*[T,E] )
    (&(e,prepended)(concat:[T,E] [(assume-except* (yield* prepended)), e]));
public function wait: ( & {timeout:Number} NoExcept[-] )
    native 'wait';
public function tick: ( & {interval:Number} NoExcept*[-] )
    native 'tick';
public function assume-except[T,E]:  ( &(NoExcept[T]) Effect[T,E] )
    native 'assume-except';
public function assume-except*[T,E]: ( &(NoExcept*[T]) Effect*[T,E] )
    native 'assume-except';

// Effect Operators
public function take-one[T,E]: ( &(Effect*[T,E]) Effect[Maybe[T],E] )
    native 'take-one';
public function take-one[T]:   ( &(NoExcept*[T]) NoExcept[Maybe[T]] )
    native 'take-one';
public function wait-complete[E]: ( &(Effect*[-,E]) Effect[-,E] )
    native 'wait-complete';
public function wait-complete:    ( &(NoExcept*[-]) NoExcept[-] )
    native 'wait-complete';
public function forever[E]: ( &(Effect*[-,E]) Effect[-,E] )
    native 'forever';
public function forever:    ( &(NoExcept*[-]) NoExcept[-] )
    native 'forever';
public function then[A,B,E]: ( &(Effect[A,E],(&(A)(Effect[B,E]))) Effect[B,E] )
    native 'then';
public function then[A,B,E]: ( &(Effect[A,E],(&(A)(NoExcept[B]))) Effect[B,E] )
    native 'then';
public function then[A,B,E]: ( &(NoExcept[A],(&(A)(Effect[B,E]))) Effect[B,E] )
    native 'then';
public function then[A,B]:   ( &(NoExcept[A],(&(A)(NoExcept[B]))) NoExcept[B] )
    native 'then';
public function then[B,E]: ( &(Effect[-,E], Effect[B,E]) Effect[B,E] )
    native 'then-shortcut';
public function then[B,E]: ( &(Effect[-,E], NoExcept[B]) Effect[B,E] )
    native 'then-shortcut';
public function then[B,E]: ( &(NoExcept[-], Effect[B,E]) Effect[B,E] )
    native 'then-shortcut';
public function then[B]:   ( &(NoExcept[-], NoExcept[B]) NoExcept[B] )
    native 'then-shortcut';
public function catch[T,E,F]: ( &(Effect[T,E],(&(E)(Effect[T,F]))) Effect[T,F] )
    native 'catch';
public function catch[T,E]: ( &(Effect[T,E],(&(E)(NoExcept[T]))) NoExcept[T] )
    native 'catch';
public function catch*[T,E,F]: ( &(Effect*[T,E],(&(E)(Effect*[T,F]))) Effect*[T,F] )
    native 'catch';
public function catch*[T,E]: ( &(Effect*[T,E],(&(E)(NoExcept*[T]))) NoExcept*[T] )
    native 'catch';
public function catch-retry[T,E]: ( &(Effect[T,E],(&(E)(NoExcept[Bool]))) Effect[T,E] )
    native 'catch-retry';
public function catch-throw[T,E,F]: ( &(Effect[T,E],(&(E)(F))) Effect[T,F] )
    native 'catch-throw';
public function throw[T,E]: ( &(E) Effect[T,E] )
    native 'throw';
public function map[A,B,E]:  ( &(Effect[A,E],(&(A)(B))) Effect[B,E] )
    native 'effect-map';
public function map[A,B]:    ( &(NoExcept[A],(&(A)(B))) NoExcept[B] )
    native 'effect-map';
public function map-to[A,B,E]: ( &(Effect[A,E],B) Effect[B,E] )
    (&(e,v)(e | map (&(_)(v))));
public function map-to[A,B]: ( &(NoExcept[A],B) NoExcept[B] )
    (&(e,v)(e | map (&(_)(v))));
public function map*[A,B,E]: ( &(Effect*[A,E],(&(A)(B))) Effect*[B,E] )
    native 'effect-map';
public function map*[A,B]:   ( &(NoExcept*[A],(&(A)(B))) NoExcept*[B] )
    native 'effect-map';
public function map?[A,B,E]: ( &(Effect*[A,E],(&(A)(Maybe[B]))) Effect*[B,E] )
    (&(e,f)(e.concat-map (&(x)(switch(f(x)): case Just(y): yield(y), case N/A: yield*([]), end))));
public function map?[A,B]:   ( &(NoExcept*[A],(&(A)(Maybe[B]))) NoExcept*[B] )
    (&(e,f)(e.concat-map (&(x)(switch(f(x)): case Just(y): yield(y), case N/A: yield*([]), end))));
public function map*-to[A,B,E]: ( &(Effect*[A,E],B) Effect*[B,E] )
    (&(e,v)(e | map* (&(_)(v))));
public function map*-to[A,B]: ( &(NoExcept*[A],B) NoExcept*[B] )
    (&(e,v)(e | map* (&(_)(v))));
public function filter[T,E]: ( &(Effect*[T,E],(&(T)(Bool))) Effect*[T,E] )
    native 'effect-filter';
public function filter[T]:   ( &(NoExcept*[T],(&(T)(Bool))) NoExcept*[T] )
    native 'effect-filter';
public function reduce[T,A,E]: ( &(Effect*[T,E],A,(&(A,T)(A))) Effect[A,E] )
    native 'effect-reduce';
public function reduce[T,A]:   ( &(NoExcept*[T],A,(&(A,T)(A))) NoExcept[A] )
    native 'effect-reduce';
public function scan[T,A,E]: ( &(Effect*[T,E],A,(&(A,T)(A))) Effect*[A,E] )
    native 'effect-scan';
public function scan[T,A]:   ( &(NoExcept*[T],A,(&(A,T)(A))) NoExcept*[A] )
    native 'effect-scan';
public function debounce[T,E]: ( &(Effect*[T,E],Number) Effect*[T,E] )
    native 'debounce-time';
public function debounce[T]:   ( &(NoExcept*[T],Number) NoExcept*[T] )
    native 'debounce-time';
public function merge-map[A,B,E]: ( &(Effect*[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'merge-map';
public function merge-map[A,B,E]: ( &(Effect*[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'merge-map';
public function merge-map[A,B,E]: ( &(NoExcept*[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'merge-map';
public function merge-map[A,B]:   ( &(NoExcept*[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'merge-map';
public function concat-map[A,B,E]: ( &(Effect*[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'concat-map';
public function concat-map[A,B,E]: ( &(Effect*[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'concat-map';
public function concat-map[A,B,E]: ( &(NoExcept*[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'concat-map';
public function concat-map[A,B]:   ( &(NoExcept*[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'concat-map';
public function mix-map[A,B,E]: ( &(Effect*[A,E],Number,(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'mix-map';
public function mix-map[A,B,E]: ( &(Effect*[A,E],Number,(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'mix-map';
public function mix-map[A,B,E]: ( &(NoExcept*[A],Number,(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'mix-map';
public function mix-map[A,B]:   ( &(NoExcept*[A],Number,(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'mix-map';
public function switch-map[A,B,E]: ( &(Effect*[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function switch-map[A,B,E]: ( &(Effect*[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'switch-map';
public function switch-map[A,B,E]: ( &(NoExcept*[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function switch-map[A,B]:   ( &(NoExcept*[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'switch-map';
public function then*[A,B,E]: ( &(Effect[A,E],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function then*[A,B,E]: ( &(Effect[A,E],(&(A)(NoExcept*[B]))) Effect*[B,E] )
    native 'switch-map';
public function then*[A,B,E]: ( &(NoExcept[A],(&(A)(Effect*[B,E]))) Effect*[B,E] )
    native 'switch-map';
public function then*[A,B]:   ( &(NoExcept[A],(&(A)(NoExcept*[B]))) NoExcept*[B] )
    native 'switch-map';
public function merge[T,E]: ( &(Array[Effect*[T,E]]) Effect*[T,E] )
    native 'effect-merge';
public function merge[T]:   ( &(Array[NoExcept*[T]]) NoExcept*[T] )
    native 'effect-merge';
public function concat[T,E]: ( &(Array[Effect*[T,E]]) Effect*[T,E] )
    native 'effect-concat';
public function concat[T]:   ( &(Array[NoExcept*[T]]) NoExcept*[T] )
    native 'effect-concat';
public function with-latest-from[A,B,E]: ( &(Effect*[A,E],Effect*[B,E]) Effect*[(A,Maybe[B]),E] )
    native 'with-latest-from';
public function with-latest-from[A,B,E]: ( &(Effect*[A,E],NoExcept*[B]) Effect*[(A,Maybe[B]),E] )
    native 'with-latest-from';
public function with-latest-from[A,B,E]: ( &(NoExcept*[A],Effect*[B,E]) Effect*[(A,Maybe[B]),E] )
    native 'with-latest-from';
public function with-latest-from[A,B]:   ( &(NoExcept*[A],NoExcept*[B]) NoExcept*[(A,Maybe[B])] )
    native 'with-latest-from';
public function combine-latest[A,B,E]: ( &(Effect*[A,E],Effect*[B,E]) Effect*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
public function combine-latest[A,B,E]: ( &(Effect*[A,E],NoExcept*[B]) Effect*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
public function combine-latest[A,B,E]: ( &(NoExcept*[A],Effect*[B,E]) Effect*[(Maybe[A],Maybe[B]),E] )
    native 'combine-latest';
public function combine-latest[A,B]:   ( &(NoExcept*[A],NoExcept*[B]) NoExcept*[(Maybe[A],Maybe[B])] )
    native 'combine-latest';
public function combine-latest[A,B,C]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C])
        NoExcept*[(Maybe[A],Maybe[B],Maybe[C])] )
    native 'combine-latest';
public function combine-latest[A,B,C,D]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C],NoExcept*[D])
        NoExcept*[(Maybe[A],Maybe[B],Maybe[C],Maybe[D])] )
    native 'combine-latest';
public function combine-latest[A,B,C,D,E]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C],NoExcept*[D],NoExcept*[E])
        NoExcept*[(Maybe[A],Maybe[B],Maybe[C],Maybe[D],Maybe[E])] )
    native 'combine-latest';
public function combine-latest![A,B,E]: ( &(Effect*[A,E],Effect*[B,E]) Effect*[(A,B),E] )
    native 'combine-latest!';
public function combine-latest![A,B,E]: ( &(Effect*[A,E],NoExcept*[B]) Effect*[(A,B),E] )
    native 'combine-latest!';
public function combine-latest![A,B,E]: ( &(NoExcept*[A],Effect*[B,E]) Effect*[(A,B),E] )
    native 'combine-latest!';
public function combine-latest![A,B]:   ( &(NoExcept*[A],NoExcept*[B]) NoExcept*[(A,B)] )
    native 'combine-latest!';
public function combine-latest![A,B,C]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C])
        NoExcept*[(A,B,C)] )
    native 'combine-latest!';
public function combine-latest![A,B,C,D]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C],NoExcept*[D])
        NoExcept*[(A,B,C,D)] )
    native 'combine-latest!';
public function combine-latest![A,B,C,D,E]:
    ( &(NoExcept*[A],NoExcept*[B],NoExcept*[C],NoExcept*[D],NoExcept*[E])
        NoExcept*[(A,B,C,D,E)] )
    native 'combine-latest!';
public function combine-latest![T,E]: ( &(Array[Effect*[T,E]]) Effect*[Array[T],E] )
    native 'combine-latest!-array';
public function combine-latest![T]: ( &(Array[NoExcept*[T]]) NoExcept*[Array[T]] )
    native 'combine-latest!-array';
