type Char    protected Uint32;       // container.Char (uint32)
type String  protected List[Char];  // container.String ([] uint32)

export function chr:
    &(Number) => Maybe[Char]
    native 'chr';

export function chr!:
    &(Number) => Char
    native 'chr!';

export function = :
    &(String,String) => Bool
    native '=String';

export function  < :
    &(String,String) => Bool
    native '<String';

export function <> :
    &(String,String) => Ordering
    native '<>String';

export function str:
    [T] (Conv[T,String])
    &(T) => String
    &(x) => { convert x };

export function convert:
    &(List[Char]) => String
    native 'String from List';

export function convert:
    &(Char) => String
    native 'String from Char';

export function convert:
    &(Number) => String
    native 'String from Number';

export function convert:
    &(Bool) => String
    native 'String from Bool';

export function convert:
    &(Float) => String
    native 'String from Float';

/// encodes string into UTF-8 byte sequence
export function encode:
    &(String) => Bytes
    native 'encode-utf8';

/// decodes string from UTF-8 byte sequence
export function decode:
    &(Bytes) => Maybe[String]
    native 'decode-utf8';

/// decodes string from UTF-8 byte sequence (outputs \uFFFD on error)
export function decode!:
    &(Bytes) => String
    native 'force-decode-utf8';

export function quote:
    &(String) => String
    native 'quote';

export function unquote:
    &(String) => Maybe[String]
    native 'unquote';

// TODO: parse-int
export function parse-real:
    &(String) => Maybe[Real]
    native 'parse-real';

export function shift:
    &(String) => Maybe[(Char,String)]
    native 'str-shift';

export function shift-prefix:
    &(String,String) => Maybe[String]
    native 'str-shift-prefix';

export function find:
    &(String,String) => Maybe[Number]
    native 'str-find';

export function contains:
    &(String,String) => Bool
    &(str,sub) =>
        switch str.{find(sub)}:
            case Some _: Yes,
            case None:    No,
        end;

export function contains:
    &(String,Char) => Bool
    &(s,char) =>
        ({ iterate s } some &(c) => (c = char));

export function concat:
    &(List[String]) => String
    native 'str-concat';

export function split:
    &(String,String) => Seq[String]
    native 'str-split';

export function join:
    &(Seq[String],String) => String
    native 'str-join';

export function join:
    &(Seq[String],Char) => String
    &(seq,char) => seq.{join({String [char]})};

export function join:
    &(List[String],String) => String
    &(arr,sep) => arr.{iterate}.{join(sep)};

export function join:
    &(List[String],Char) => String
    &(arr,char) => arr.{iterate}.{join(char)};

export function trim:
    &(String,Char) => String
    native 'trim';

export function trim-left:
    &(String,Char) => String
    native 'trim-left';

export function trim-right:
    &(String,Char) => String
    native 'trim-right';

export function trim-prefix:
    &(String,String) => String
    native 'trim-prefix';

export function trim-suffix:
    &(String,String) => String
    native 'trim-suffix';

export function has-prefix:
    &(String,String) => Bool
    native 'has-prefix';

export function has-suffix:
    &(String,String) => Bool
    native 'has-suffix';
