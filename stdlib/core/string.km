type Char    protected Uint32;  // container.Char (uint32)
type String  Array[Char];  // container.String ([] uint32)

public function  = :(&(String,String)(Bool))      native '=String';
public function  < :(&(String,String)(Bool))      native '<String';
public function <> :(&(String,String)(Ordering))  native '<>String';

public function str[T]: implicit[Cast[T,String]] (&(T)(String))
    (&(x)(from x));
public function from: (&(Char)(String))    native 'String from Char';
public function from: (&(Number)(String))  native 'String from Number';
public function from: (&(Float)(String))   native 'String from Float';

// encodes string into UTF-8 byte sequence
public function encode:  (&(String)(Bytes))         native 'encode-utf8';
// decodes string from UTF-8 byte sequence
public function decode:  (&(Bytes)(Maybe[String]))  native 'decode-utf8';
// decodes string from UTF-8 byte sequence (outputs \uFFFD on errors)
public function decode!: (&(Bytes)(String))         native 'force-decode-utf8';

public function quote:   (&(String)(String))         native 'quote';
public function unquote: (&(String)(Maybe[String]))  native 'unquote';

// TODO: parse-int
public function parse-float: (&(String)(Maybe[Float]))  native 'parse-float';

public function substr: (&(String,Range)(String))
    ( &(str,range) (String (str.slice range)) );

public function find: (&(String,String)(Maybe[Number]))  native 'str-find';
public function contains: (&(String,String)(Bool))
    ( &(str,sub)
        switch (str.find sub):
            case Just _: Yes,
            case N/A:    No,
        end
    );
public function contains: (&(String,Char)(Bool))
    ( &(str,char)(str.some (&(c) $(c = char))) );

// TODO: fix Array Seq inconsistency
public function concat: (&(Array[String])(String))      native 'str-concat';
public function split:  (&(String,String)(Seq[String])) native 'str-split';
public function join:   (&(Seq[String],String)(String)) native 'str-join';
public function join:   (&(Seq[String],Char)(String))
    (&(seq,char)(seq.join (String [char])));

// TODO: trim-{,left,right}, {trim,has}-{prefix,suffix}
