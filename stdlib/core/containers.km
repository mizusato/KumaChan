// Container Types
type Seq[+T]     native;  // container.Seq
type Array[+T]   native;  // []T, container.Array
type Heap[+T]    native;  // container.Heap
type Set[+T]     native;  // container.Set
type Map[+K,+V]  native;  // container.Map
type List[+T]    native;  // container.List
type ListKey     String;


/* Functions for Seq[T] */

public function collect[T]: ( &(Seq[T]) Array[T] )
    native 'seq-collect';

public function next[T]: ( &(Seq[T]) Maybe[(T,Seq[T])] )
    native 'seq-next';
public function nil[T]:  ( &() Seq[T] )
    native 'seq-nil';
public function cons[T]: ( &(T,Seq[T]) Seq[T] )
    native 'seq-cons';

public function map[A,B]:      ( &(Seq[A],(&(A)(B))) Seq[B] )
    native 'seq-map';
public function map?[A,B]:     ( &(Seq[A],(&(A)(Maybe[B]))) Seq[B] )
    native 'seq-map?';
public function filter[T]:     ( &(Seq[T],(&(T)(Bool))) Seq[T] )
    native 'seq-filter';
public function flat-map[A,B]: ( &(Seq[A],(&(A)(Seq[B]))) Seq[B] )
    native 'seq-flat-map';

public function scan[T,A]:   ( &(Seq[T],A,(&(A,T)(A))) Seq[A] )
    native 'seq-scan';
public function reduce[T,A]: ( &(Seq[T],A,(&(A,T)(A))) A )
    native 'seq-reduce';

public function some[T]:  ( &(Seq[T],(&(T)(Bool))) Bool )
    native 'seq-some';
public function every[T]: ( &(Seq[T],(&(T)(Bool))) Bool )
    native 'seq-every';

public function chunk[T]:  ( &(Seq[T],Number) Seq[Array[T]] )
    native 'seq-chunk';
public function concat[T]: ( &(Array[Seq[T]]) Seq[T] )
    (&(array)(array.iterate.flat-map (&(x)(x))));


/* Functions of Array[T] */

public function iterate[T]: ( &(Array[T]) Seq[T] )
    native 'array-iterate';

public function at[T]: ( &(Array[T],Number) Maybe[T] )
    native 'array-at';
public function at![T]: ( &(Array[T],Number) T )
    native 'array-at!';
public function length[T]: ( &(Array[T]) Number )
    native 'array-length';

public function reverse[T]: ( &(Array[T]) Array[T] )
    native 'array-reverse';

public function slice[T]:      ( &(Array[T],Range) Array[T] )
    native 'array-slice';
public function slice-view[T]: ( &(Array[T],Range) Array[T] )
    native 'array-slice-view';

public function map[A,B]:      ( &(Array[A],(&(A)(B))) Array[B] )
    native 'array-map';
public function map-view[A,B]: ( &(Array[A],(&(A)(B))) Array[B] )
    native 'array-map-view';

public function filter[T]: ( &(Array[T],(&(T)(Bool))) Array[T] )
    ( &(arr,f) (arr | iterate | filter f | collect) );

public function scan[T,A]:   ( &(Array[T],A,(&(A,T)(A))) Array[A] )
    ( &(arr,init,f) (arr | iterate | scan init f | collect) );
public function reduce[T,A]: ( &(Array[T],A,(&(A,T)(A))) A )
    ( &(arr,init,f) (arr | iterate | reduce init f) );

public function some[T]:  ( &(Array[T],(&(T)(Bool))) Bool )
    ( &(arr,f) (arr | iterate | some f) );
public function every[T]: ( &(Array[T],(&(T)(Bool))) Bool )
    ( &(arr,f) (arr | iterate | every f) );


/* Functions of Set[T] */

public function new-set[T]: ( &((&(T,T)(Ordering)),Array[T]) Set[T] )
    native 'new-set';
public function has[T]: ( &(Set[T],T) Bool )
    native 'set-has';

/* Functions of Map[K,V] */

public function new-map[T]: ( &(Array[(String,T)]) Map[String,T] )
    native 'new-map-str';
public function entries[K,V]: ( &(Map[K,V]) Array[(K,V)] )
    native 'map-entries';
public function iterate[K,V]: ( &(Map[K,V]) Seq[(K,V)] )
    ( &(m) (m.entries.iterate) );
public function get[K,V]: ( &(Map[K,V],K) Maybe[V] )
    native 'map-get';
public function get![K,V]: ( &(Map[K,V],K) V )
    native 'map-get!';
public function insert*[K,V]: ( &(Map[K,V],K,V) Map[K,V] )
    native 'map-insert*';
public function delete*[K,V]: ( &(Map[K,V],K) Map[K,V] )
    native 'map-delete*';


/* Functions for List[T] */

public function new-list[T]: ( &(Array[T],(&(T)(ListKey))) List[T] )
    native 'new-list';
public function iterate[T]:  ( &(List[T]) Seq[(ListKey,T)] )
    native 'list-iterate';
public function length[T]:  ( &(List[T]) Number )
    native 'list-length';
public function has[T]:     ( &(List[T],ListKey) Bool )
    native 'list-has';
public function get[T]:     ( &(List[T],ListKey) T )
    native 'list-get';
public function update[T]:  ( &(List[T],ListKey,(&(T)(T))) List[T] )
    native 'list-update';
public function delete[T]:  ( &(List[T],ListKey) List[T] )
    native 'list-delete';
public function prepend[T]: ( &(List[T],(ListKey,T)) List[T] )
    native 'list-prepend';
public function append[T]:  ( &(List[T],(ListKey,T)) List[T] )
    native 'list-append';
public function insert[T]:  ( &(List[T],{before:ListKey},(ListKey,T)) List[T] )
    native 'list-insert-before';
public function insert[T]:  ( &(List[T],{after:ListKey},(ListKey,T)) List[T] )
    native 'list-insert-after';
public function move[T]:      ( &(List[T],ListKey,{before:ListKey}) List[T] )
    native 'list-move-before';
public function move[T]:      ( &(List[T],ListKey,{after:ListKey}) List[T] )
    native 'list-move-after';
public function move-up[T]:   ( &(List[T],ListKey) List[T] )
    native 'list-move-up';
public function move-down[T]: ( &(List[T],ListKey) List[T] )
    native 'list-move-down';
public function swap[T]:      ( &(List[T],ListKey,ListKey) List[T] )
    native 'list-swap';

public function is-first-in[T]: ( &(NoExcept*[Number],Reactive[List[T]]) NoExcept*[Bool] )
    ( &(@index,_)
        @index.map* (&(index) $(index = 0))
    );
public function is-last-in[T]: ( &(NoExcept*[Number],Reactive[List[T]]) NoExcept*[Bool] )
    ( &(@index,@list)
        ~ map* &(index,length) := combine-latest! @index (@list.watch.map* (&(list)(list.length))),
        $(index = $(length - 1))
    );
// TODO: more APIs for Reactive[List[T]]

