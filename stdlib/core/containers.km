// Container Types
type Seq[+T]     native;  // container.Seq
type Array[+T]   native;  // []T, container.Array
type Heap[+T]    native;  // container.Heap
type Set[+T]     native;  // container.Set
type Map[+K,+V]  native;  // container.Map
type List[+T]    native;  // container.List
type ListKey     String;


/* Functions for Seq[T] */

export function collect:[T]
    &(Seq[T]) => Array[T]
    native 'seq-collect';

export function next:[T]
    &(Seq[T]) => Maybe[(T,Seq[T])]
    native 'seq-next';
export function nil:[T]
    &() => Seq[T]
    native 'seq-nil';
export function cons:[T]
    &(T,Seq[T]) => Seq[T]
    native 'seq-cons';

export function seq:
    & { from: Number, to: Number } => Seq[Number]
    native 'seq-range-inclusive';
export function seq:
    & { start: Number, count: Number } => Seq[Number]
    native 'seq-range-count';

export function map:[A,B]
    &(Seq[A], &(A) => B) => Seq[B]
    native 'seq-map';
export function filter-map:[A,B]
    &(Seq[A], &(A) => Maybe[B]) => Seq[B]
    native 'seq-filter-map';
export function filter:[T]
    &(Seq[T], &(T) => Bool) => Seq[T]
    native 'seq-filter';
export function flat-map:[A,B]
    &(Seq[A], &(A) => Seq[B]) => Seq[B]
    native 'seq-flat-map';

export function scan:[T,A]
    &(Seq[T], A, &(A,T) => A) => Seq[A]
    native 'seq-scan';
export function scan:[T,A]
    &(Seq[T], (A, &(A,T) => A)) => Seq[A]
    &(seq,opts) => let (init,f) := opts, { scan (seq,init,f) };
export function reduce:[T,A]
    &(Seq[T], A, &(A,T) => A) => A
    native 'seq-reduce';
export function reduce:[T,A]
    &(Seq[T], (A, &(A,T) => A)) => A
    &(seq,opts) => let (init,f) := opts, { reduce (seq,init,f) };

export function some:[T]
    &(Seq[T], &(T) => Bool) => Bool
    native 'seq-some';
export function every:[T]
    &(Seq[T], &(T) => Bool) => Bool
    native 'seq-every';

export function chunk:[T]
    &(Seq[T], Number) => Seq[Array[T]]
    native 'seq-chunk';
export function concat:[T]
    &(Array[Seq[T]]) => Seq[T]
    &(array) => array.{iterate}.{flat-map(&(items) => items)};


/* Functions of Array[T] */

export function iterate:[T]
    &(Array[T]) => Seq[T]
    native 'array-iterate';

export function at:[T]
    &(Array[T], Number) => Maybe[T]
    native 'array-at';
export function at!:[T]
    &(Array[T], Number) => T
    native 'array-at!';
export function length:[T]
    &(Array[T]) => Number
    native 'array-length';

export function reverse:[T]
    &(Array[T]) => Array[T]
    native 'array-reverse';

export function slice:[T]
    &(Array[T], Number, Number) => Array[T]
    native 'array-slice';
export function slice:[T]
    &(Array[T], (Number,Number)) => Array[T]
    &(a,range) => let (l,r) := range, { slice (a,l,r) };
export function slice-view:[T]
    &(Array[T], Number, Number) => Array[T]
    native 'array-slice-view';
export function slice-view:[T]
    &(Array[T], (Number,Number)) => Array[T]
    &(a,range) => let (l,r) := range, { slice-view (a,l,r) };

export function map:[A,B]
    &(Array[A], &(A) => B) => Array[B]
    native 'array-map';
export function map-view:[A,B]
    &(Array[A], &(A) => B) => Array[B]
    native 'array-map-view';

export function filter:[T]
    &(Array[T], &(T) => Bool) => Array[T]
    &(arr,f) => arr.{iterate}.{filter(f)}.{collect};

export function scan:[T,A]
    &(Array[T], (A, &(A,T) => A)) => Array[A]
    &(arr,opts) => arr.{iterate}.{scan(opts)}.{collect};
export function reduce:[T,A]
    &(Array[T], (A, &(A,T) => A)) => A
    &(arr,opts) => arr.{iterate}.{reduce(opts)};

export function some:[T]
    &(Array[T], &(T) => Bool) => Bool
    &(arr,f) => arr.{iterate}.{some(f)};
export function every:[T]
    &(Array[T], &(T) => Bool) => Bool
    &(arr,f) => arr.{iterate}.{every(f)};


/* Functions of Set[T] */

export function new-set:[T]
    &(&(T,T) => Ordering, Array[T]) => Set[T]
    native 'new-set';
export function has:[T]
    &(Set[T], T) => Bool
    native 'set-has';

/* Functions of Map[K,V] */

export function create-map:[T]
    &(Array[(String,T)]) => Map[String,T]
    native 'create-map-str';
export function entries:[K,V]
    &(Map[K,V]) => Array[(K,V)]
    native 'map-entries';
export function iterate:[K,V]
    &(Map[K,V]) => Seq[(K,V)]
    &(m) => m.{entries}.{iterate};
export function get:[K,V]
    &(Map[K,V], K) => Maybe[V]
    native 'map-get';
export function get!:[K,V]
    &(Map[K,V], K) => V
    native 'map-get!';
export function insert:[K,V]
    &(Map[K,V], K, V) => Maybe[Map[K,V]]
    native 'map-insert';
export function insert*:[K,V]
    &(Map[K,V], K, V) => Map[K,V]
    native 'map-insert*';
export function delete:[K,V]
    &(Map[K,V], K) => Maybe[(V,Map[K,V])]
    native 'map-delete';
export function delete*:[K,V]
    &(Map[K,V], K) => Map[K,V]
    native 'map-delete*';


/* Functions for List[T] */

export function create-list:[T]
    &(Array[T], &(T) => ListKey) => List[T]
    native 'create-list';
export function empty-list:[T]
    &() => List[T]
    native 'empty-list';
export function iterate:[T]
    &(List[T]) => Seq[(ListKey,T)]
    native 'list-iterate';
export function length:[T]
    &(List[T]) => Number
    native 'list-length';
export function has:[T]
    &(List[T], ListKey) => Bool
    native 'list-has';
export function get:[T]
    &(List[T], ListKey) => T
    native 'list-get';
export function update:[T]
    &(List[T], ListKey, &(T) => T) => List[T]
    native 'list-update';
export function delete:[T]
    &(List[T], ListKey) => List[T]
    native 'list-delete';
export function prepend:[T]
    &(List[T], (ListKey,T)) => List[T]
    native 'list-prepend';
export function append:[T]
    &(List[T], (ListKey,T)) => List[T]
    native 'list-append';
export function insert:[T]
    &(List[T], {before:ListKey}, (ListKey,T)) => List[T]
    native 'list-insert-before';
export function insert:[T]
    &(List[T], {after:ListKey}, (ListKey,T)) => List[T]
    native 'list-insert-after';
export function move:[T]
    &(List[T], ListKey, {before:ListKey}) => List[T]
    native 'list-move-before';
export function move:[T]
    &(List[T], ListKey, {after:ListKey}) => List[T]
    native 'list-move-after';
export function move-up:[T]
    &(List[T], ListKey) => List[T]
    native 'list-move-up';
export function move-down:[T]
    &(List[T], ListKey) => List[T]
    native 'list-move-down';
export function swap:[T]
    &(List[T], ListKey, ListKey) => List[T]
    native 'list-swap';

// TODO: type ListItemIndexWatch protected Action*[Number]
export function is-first-in:[T]
    &(Action*[Number], Reactive[List[T]]) => Action*[Bool]
    &(@index, _) =>
        @index
            . { map &(index) => (index = 0) }
            . { distinct-until-changed };
export function is-last-in:[T]
    &(Action*[Number], Reactive[List[T]]) => Action*[Bool]
    &(@index,@list) =>
        let @length := ({ watch @list } map &(list) => list.{length}),
        { combine-latest* (@index, @length) }
            . { map &(index,length) => (index = (length - 1)) }
            . { distinct-until-changed };

export function update:[T]
    &(Reactive[List[T]], ListKey, &(T) => T) => Action
    &(@list,key,f) => @list.{ update &(list) => {update(list,key,f)} };
export function delete:[T]
    &(Reactive[List[T]], ListKey) => Action
    &(@list,key) => @list.{ update &(list) => {delete(list,key)} };
export function prepend:[T]
    &(Reactive[List[T]], (ListKey,T)) => Action
    &(@list,entry) => @list.{ update &(list) => {prepend(list,entry)} };
export function append:[T]
    &(Reactive[List[T]], (ListKey,T)) => Action
    &(@list,entry) => @list.{ update &(list) => {append(list,entry)} };
export function insert:[T]
    &(Reactive[List[T]], {before:ListKey}, (ListKey,T)) => Action
    &(@list,pos,entry) => @list.{ update &(list) => {insert(list,pos,entry)} };
export function insert:[T]
    &(Reactive[List[T]], {after:ListKey}, (ListKey,T)) => Action
    &(@list,pos,entry) => @list.{ update &(list) => {insert(list,pos,entry)} };
export function move:[T]
    &(Reactive[List[T]], ListKey, {before:ListKey}) => Action
    &(@list,key,pos) => @list.{ update &(list) => {move(list,key,pos)} };
export function move:[T]
    &(Reactive[List[T]], ListKey, {after:ListKey}) => Action
    &(@list,key,pos) => @list.{ update &(list) => {move(list,key,pos)} };
export function move-up:[T]
    &(Reactive[List[T]], ListKey) => Action
    &(@list,key) => @list.{ update &(list) => {move-up(list,key)} };
export function move-down:[T]
    &(Reactive[List[T]], ListKey) => Action
    &(@list,key) => @list.{ update &(list) => {move-down(list,key)} };
export function swap:[T]
    &(Reactive[List[T]], ListKey, ListKey) => Action
    &(@list,key1,key2) => @list.{ update &(list) => {swap(list,key1,key2)} };
