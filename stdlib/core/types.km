/**
 *  IMPORTANT: The following type definitions should be kept consistent
 *             with the `stdlib.go` file.
 */

// Basic Numeric Types
type Float   native;  // float64 except NaN and Infinity values
type Float*  native;  // float64
type Number  native;  // uint (size_t), with overflow/underflow checking
type Int8    native;  // int8
type Int16   native;  // int16
type Int32   native;  // int32
type Int64   native;  // int64
type Uint8   native;  // uint8
type Uint16  native;  // uint16
type Uint32  native;  // uint32
type Uint64  native;  // uint64

// Integer Conversions
public function from: (&(Uint32)(Number))  native 'Number from Uint32';
public function from: (&(Uint16)(Number))  native 'Number from Uint16';
public function from: (&(Uint8)(Number))  native 'Number from Uint8';

// Float <-> Float*
public function from: ( &(Float) Float* )
    native 'Float* from Float';
public function check-nan-inf: ( &(Float*) Maybe[Float] )
    native 'check-nan-inf-float';

// Basic Sum Types
type Bool enum {
    type Yes;
    type No;
};
type Maybe[+T] enum {
    type Just[+T] weak T;
    type N/A;
};
type Result[+T,+E] enum {
    type OK[+T] weak T;
    type NG[+E] weak E;
};
type Ordering enum {
    type <<;
    type ==;
    type >>;
};
public function =: ( &(Bool,Bool) Bool )  native 'sum-index-equal';
public function =: ( &(Ordering,Ordering) Bool )  native 'sum-index-equal';

// Type Cast
type Cast[T,U] implicit {
    from: (& T U)
};
public function to[T,U]: implicit[Cast[T,U]] ( &(T) U )
    ( &(t)
        from t
    );

public function assume[T]:   ( &((Bool,T),(&()(T))) T )
    ( &(input,k)
        let (cond, fallback) := input,
        if cond:
            k(),
        else:
            fallback
    );

public function maybe[A,B]:  ( &(Maybe[A],(&(A)(B))) Maybe[B] )
    ( &(v?, f)
        switch v?:
        case Just v:
            Just (f v),
        case N/A:
            N/A,
        end
    );

public function maybe[A,B]:  ( &((Maybe[A],B),(&(A)(B))) B )
    ( &(input, f)
        let (v?, fallback) := input,
        switch v?:
        case Just v:
            f v,
        case N/A:
            fallback,
        end
    );


// -----------

public function maybe?[A,B]: ( &(Maybe[A],(&(A)(Maybe[B]))) Maybe[B] )
    ( &(v?, k)
        switch v?:
        case Just v:
            (k v),
        case N/A:
            N/A,
        end
    );

public function unwrap?[T]: ( &(Maybe[Maybe[T]]) Maybe[T] )
    ( &(v??)
        switch v??:
        case Just v?:
            switch v?:
            case Just v:
                Just v,
            case N/A:
                N/A,
            end,
        case N/A:
            N/A,
        end
    );

public function fallback?[T]: ( &(Maybe[T],T) T )
    ( & (t?, fallback)
        switch t?:
        case Just t:
            t,
        case N/A:
            fallback,
        end
    );
