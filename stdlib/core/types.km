/**
 *  IMPORTANT: The following type definitions should be kept consistent
 *             with the `stdlib.go` file.
 */

// TODO: split this file

// Basic Numeric Types
type Real    protected Float;  // float64 except NaN and Infinity values
type Float   native;  // float64
type Number  native;  // uint (size_t), with overflow/underflow checking
type Int8    native;  // int8
type Int16   native;  // int16
type Int32   native;  // int32
type Int64   native;  // int64
type Uint8   native;  // uint8
type Uint16  native;  // uint16
type Uint32  native;  // uint32
type Uint64  native;  // uint64

// Integer Conversions
export function convert:
    &(Uint32) => Number
    native 'Number from Uint32';
export function convert:
    &(Uint16) => Number
    native 'Number from Uint16';
export function convert:
    &(Uint8) => Number
    native 'Number from Uint8';

export function convert:
    &(Float) => Maybe[Real]
    native 'Float to Maybe[Real]';

// Basic Sum Types
type Bool enum {
    type Yes;
    type No;
};
// TODO: consider renaming "Just"
type Maybe[+T] enum {
    type Just[+T] weak T;
    type Null;
};
type Result[+T,+E] enum {
    type OK[+T] weak T;
    type NG[+E] weak E;
};
type Ordering enum {
    type <<;
    type ==;
    type >>;
};
export function =:
    &(Bool,Bool) => Bool
    native 'sum-index-equal';
export function =:
    &(Ordering,Ordering) => Bool
    native 'sum-index-equal';

type Optional[+T] Maybe[T];
export function zero-value:
    &() => Optional[never]
    &() => Null;

// Type Conversion
type Conv[T,U] implicit {
    convert: &(T) => U
};

export function assume:[T]
    &((Bool,T), &() => T) => T
    &(input, k) =>
        let (cond, fallback) := input,
        if cond:
            { k () },
        else:
            fallback;


// ----------
// TODO: rename the following functions

export function maybe:[A,B]
    &(Maybe[A], &(A) => B) => Maybe[B]
    &(v?, f) =>
        switch v?:
        case Just v:
            { Just { f v } },
        case Null:
            Null,
        end;

export function maybe:[A,B]
    &((Maybe[A],B), &(A) => B) => B
    &(input, f) =>
        let (v?, fallback) := input,
        switch v?:
        case Just v:
            { f(v) },
        case Null:
            fallback,
        end;

export function maybe?:[A,B]
    &(Maybe[A], &(A) => Maybe[B]) => Maybe[B]
    &(v?, k) =>
        switch v?:
        case Just v:
            { k v },
        case Null:
            Null,
        end;

export function unwrap?:[T]
    &(Maybe[Maybe[T]]) => Maybe[T]
    &(v??) =>
        switch v??:
        case Just v?:
            switch v?:
            case Just v:
                { Just v },
            case Null:
                Null,
            end,
        case Null:
            Null,
        end;

export function fallback?:[T]
    &(Maybe[T], T) => T
    &(t?, fallback) =>
        switch t?:
        case Just t:
            t,
        case Null:
            fallback,
        end;

