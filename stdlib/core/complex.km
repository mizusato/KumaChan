type Complex
    protected
    FloatComplex; // complex128 except NaN and Infinity values
type FloatComplex
    native; // complex128

export function complex:
    &(Real,Real) => Complex
    native 'complex';
export function polar:
    &(Real,Real) => Complex
    native 'polar';
export function complex:
    &(Float,Float) => FloatComplex
    native 'complex';
export function polar:
    &(Float,Float) => FloatComplex
    native 'polar';

export function convert:
    &(FloatComplex) => Maybe[Complex]
    native 'FloatComplex to Maybe[Complex]';

export function convert:
    &(Real) => Complex
    &(x) => { complex (x, 0.0) };
export function convert:
    &(Float) => FloatComplex
    &(x) => { complex (x, (0.0).[Float]) };

export function convert:
    &(FloatComplex) => String
    &(z) => { "(# + #i)" (z.{<real>}.{str}, z.{<imag>}.{str}) };

export function <conj>: &(Complex) => Complex  native '<conj>';
export function <real>: &(Complex) => Real     native '<real>';
export function <imag>: &(Complex) => Real     native '<imag>';
export function <norm>: &(Complex) => Real     native '<norm>';
export function <arg>:  &(Complex) => Real     native '<arg>';

export function <conj>: &(FloatComplex) => FloatComplex  native '<conj>';
export function <real>: &(FloatComplex) => Float         native '<real>';
export function <imag>: &(FloatComplex) => Float         native '<imag>';
export function <norm>: &(FloatComplex) => Float         native '<norm>';
export function <arg>:  &(FloatComplex) => Float         native '<arg>';

export function +: &(Complex,Complex) => Complex  native 'c+c';
export function +: &(Real,Complex) => Complex     native 'r+c';
export function +: &(Complex,Real) => Complex     native 'c+r';
export function -: &(Complex,Complex) => Complex  native 'c-c';
export function -: &(Real,Complex) => Complex     native 'r-c';
export function -: &(Complex,Real) => Complex     native 'c-r';
export function -: &(Complex) => Complex          &(z) => (-1.0 * z);
export function *: &(Complex,Complex) => Complex  native 'c*c';
export function *: &(Real,Complex) => Complex     native 'r*c';
export function *: &(Complex,Real) => Complex     native 'c*r';
export function /: &(Complex,Complex) => Complex  native 'c/c';
export function /: &(Real,Complex) => Complex     native 'r/c';
export function /: &(Complex,Real) => Complex     native 'c/r';

export function +: &(FloatComplex,FloatComplex) => FloatComplex  native '[f] c+c';
export function +: &(Float,FloatComplex) => FloatComplex         native '[f] r+c';
export function +: &(FloatComplex,Float) => FloatComplex         native '[f] c+r';
export function -: &(FloatComplex,FloatComplex) => FloatComplex  native '[f] c-c';
export function -: &(Float,FloatComplex) => FloatComplex         native '[f] r-c';
export function -: &(FloatComplex,Float) => FloatComplex         native '[f] c-r';
export function -: &(FloatComplex) => FloatComplex               &(z) => (0.0.[Float] - z);
export function *: &(FloatComplex,FloatComplex) => FloatComplex  native '[f] c*c';
export function *: &(Float,FloatComplex) => FloatComplex         native '[f] r*c';
export function *: &(FloatComplex,Float) => FloatComplex         native '[f] c*r';
export function /: &(FloatComplex,FloatComplex) => FloatComplex  native '[f] c/c';
export function /: &(Float,FloatComplex) => FloatComplex         native '[f] r/c';
export function /: &(FloatComplex,Float) => FloatComplex         native '[f] c/r';

export function sqrt: &(Complex) => Complex  native 'complex-sqrt';
export function cbrt: &(Complex) => Complex  native 'complex-cbrt';
export function  exp: &(Complex) => Complex  native 'complex-exp';
export function  log: &(Complex) => Complex  native 'complex-log';
export function  sin: &(Complex) => Complex  native 'complex-sin';
export function  cos: &(Complex) => Complex  native 'complex-cos';
export function  tan: &(Complex) => Complex  native 'complex-tan';
export function asin: &(Complex) => Complex  native 'complex-asin';
export function acos: &(Complex) => Complex  native 'complex-acos';
export function atan: &(Complex) => Complex  native 'complex-atan';

export function sqrt: &(FloatComplex) => FloatComplex  native '[f] complex-sqrt';
export function cbrt: &(FloatComplex) => FloatComplex  native '[f] complex-cbrt';
export function  exp: &(FloatComplex) => FloatComplex  native '[f] complex-exp';
export function  log: &(FloatComplex) => FloatComplex  native '[f] complex-log';
export function  sin: &(FloatComplex) => FloatComplex  native '[f] complex-sin';
export function  cos: &(FloatComplex) => FloatComplex  native '[f] complex-cos';
export function  tan: &(FloatComplex) => FloatComplex  native '[f] complex-tan';
export function asin: &(FloatComplex) => FloatComplex  native '[f] complex-asin';
export function acos: &(FloatComplex) => FloatComplex  native '[f] complex-acos';
export function atan: &(FloatComplex) => FloatComplex  native '[f] complex-atan';
