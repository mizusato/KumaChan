type Complex  native;  // complex128 except NaN and Infinity values
type Complex* native;  // complex128

export function complex:
    &(Float,Float) => Complex
    native 'complex';
export function polar:
    &(Float,Float) => Complex
    native 'polar';
export function complex:
    &(Float*,Float*) => Complex*
    native 'complex';
export function polar:
    &(Float*,Float*) => Complex*
    native 'polar';

export function convert:
    &(Complex) => Complex*
    native 'Complex* from Complex';
export function check-nan-inf:
    &(Complex*) => Maybe[Complex]
    native 'check-nan-inf-complex';

export function convert:
    &(Float) => Complex
    &(x) => { complex (x, 0.0) };
export function convert:
    &(Float*) => Complex*
    &(x) => { complex (x, {convert 0.0}.[Float*]) };

export function convert:
    &(Complex) => String
    &(z) => { "(# + #i)" (z.{<real>}.{str}, z.{<imag>}.{str}) };
export function convert:
    &(Complex*) => String
    &(z*) =>
        switch {check-nan-inf z*}:
            case Just z: { convert z }.[String],
            case N/A:    'INVALID',
        end;

export function <conj>: &(Complex) => Complex  native '<conj>';
export function <real>: &(Complex) => Float    native '<real>';
export function <imag>: &(Complex) => Float    native '<imag>';
export function <norm>: &(Complex) => Float    native '<norm>';
export function <arg>:  &(Complex) => Float    native '<arg>';

export function <conj>: &(Complex*) => Complex*  native '<conj>';
export function <real>: &(Complex*) => Float*    native '<real>';
export function <imag>: &(Complex*) => Float*    native '<imag>';
export function <norm>: &(Complex*) => Float*    native '<norm>';
export function <arg>:  &(Complex*) => Float*    native '<arg>';

export function +: &(Complex,Complex) => Complex  native '+complex';
export function +: &(Float,Complex) => Complex    native 'f+complex';
export function +: &(Complex,Float) => Complex    native 'complex+f';
export function -: &(Complex,Complex) => Complex  native '-complex';
export function -: &(Float,Complex) => Complex    native 'f-complex';
export function -: &(Complex,Float) => Complex    native 'complex-f';
export function -: &(Complex) => Complex          &(z) => (-1.0 * z);
export function *: &(Complex,Complex) => Complex  native '*complex';
export function *: &(Float,Complex) => Complex    native 'f*complex';
export function *: &(Complex,Float) => Complex    native 'complex*f';
export function /: &(Complex,Complex) => Complex  native '/complex';
export function /: &(Float,Complex) => Complex    native 'f/complex';
export function /: &(Complex,Float) => Complex    native 'complex/f';

export function +: &(Complex*,Complex*) => Complex*  native '+complex*';
export function +: &(Float*,Complex*) => Complex*    native 'f+complex*';
export function +: &(Complex*,Float*) => Complex*    native 'complex+f*';
export function -: &(Complex*,Complex*) => Complex*  native '-complex*';
export function -: &(Float*,Complex*) => Complex*    native 'f-complex*';
export function -: &(Complex*,Float*) => Complex*    native 'complex-f*';
export function -: &(Complex*) => Complex*           &(z) => ({ convert 0.0 }.[Float*] - z);
export function *: &(Complex*,Complex*) => Complex*  native '*complex*';
export function *: &(Float*,Complex*) => Complex*    native 'f*complex*';
export function *: &(Complex*,Float*) => Complex*    native 'complex*f*';
export function /: &(Complex*,Complex*) => Complex*  native '/complex*';
export function /: &(Float*,Complex*) => Complex*    native 'f/complex*';
export function /: &(Complex*,Float*) => Complex*    native 'complex/f*';

export function sqrt: &(Complex) => Complex  native 'complex-sqrt';
export function cbrt: &(Complex) => Complex  native 'complex-cbrt';
export function  exp: &(Complex) => Complex  native 'complex-exp';
export function  log: &(Complex) => Complex  native 'complex-log';
export function  sin: &(Complex) => Complex  native 'complex-sin';
export function  cos: &(Complex) => Complex  native 'complex-cos';
export function  tan: &(Complex) => Complex  native 'complex-tan';
export function asin: &(Complex) => Complex  native 'complex-asin';
export function acos: &(Complex) => Complex  native 'complex-acos';
export function atan: &(Complex) => Complex  native 'complex-atan';

export function sqrt: &(Complex*) => Complex*  native 'complex-sqrt*';
export function cbrt: &(Complex*) => Complex*  native 'complex-cbrt*';
export function  exp: &(Complex*) => Complex*  native 'complex-exp*';
export function  log: &(Complex*) => Complex*  native 'complex-log*';
export function  sin: &(Complex*) => Complex*  native 'complex-sin*';
export function  cos: &(Complex*) => Complex*  native 'complex-cos*';
export function  tan: &(Complex*) => Complex*  native 'complex-tan*';
export function asin: &(Complex*) => Complex*  native 'complex-asin*';
export function acos: &(Complex*) => Complex*  native 'complex-acos*';
export function atan: &(Complex*) => Complex*  native 'complex-atan*';
