import service from './service';


type Server {
    users:   Reactive[Map[String,User]],
    msg-bus: Bus[service::Message]
};

type User {
    conn: rpc::Connection
};

type Chat {
    id:  String,
    ctx: Server
};

function new-chat:
    &(Server) => service::constructor
    &(ctx) => &(login,conn) =>
        let { nickname } := login,
        let id := nickname,
        let user := { User { conn } },
        let try-login: Atomic[Bool] :=
            let { users } := ctx,
            & old-users := do { read users },
            switch old-users.{ insert (id, user) }:
            case Just new-users:
                & do { write (users, new-users) },
                { yield Yes },
            case Null:
                { yield No },
            end,
        & ok := await try-login,
        if ok:
            let chat := { Chat { ctx, id } },
            let instance := { service::create chat },
            { yield instance },
        else:
            { throw { make-error { "nickname '#' is in use" id } } };

function delete:
    &(Chat) => Action
    &(chat) =>
        chat.ctx.users.{update &(old-users) => old-users.{delete* chat.id}};

function say:
    &(Chat,service::MessageContent) => Action[service::None,Error]
    &(chat,content) =>
        let msg := { service::Message {
            from: chat.id,
            content
        } },
        & do (chat.ctx.msg-bus <- msg),
        { yield service::None };

function messages:
    &(Chat,service::None) => Observable[service::Message,Error]
    &(chat,_) =>
        {watch chat.ctx.msg-bus};

do
    & users := reactive { create-map::[User] [] },
    & msg-bus := bus::[service::Message] (),
    let ctx := { Server { users, msg-bus } },
    { rpc::serve {
        service: service::identifier,
        backend: { rpc::server-cleartext { network: 'tcp', addr: '127.0.0.1:8002' } },
        options: {},
        constructor: { new-chat ctx }
    } }
    . { crash-on-error };
